<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LATIN PCD Viewer</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" integrity="sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-Piv4xVNRyMGpqkS2by6br4gNJ7DXjqk09RmUpJ8jgGtD7zP9yug3goQfGII0yAns" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="sidemenu">
        <h2 class="bg-info p-2 text-white w-100">Nuvens</h2>

        <div class="load-image p1-all">
            <div class="input-group mb-3">
                <div class="input-group-prepend">
                    <span class="input-group-text">Carregue uma nuvem:</span>
                </div>
                <div class="custom-file">
                    <input type="file" class="custom-file-input" id="pcdInputFile" name="pcdInputFile" accept=".pcd">
                    <label class="custom-file-label" for="pcdInputFile">Clique aqui</label>
                </div>
            </div>

            <input id="clearSceneCheckbox" type="checkbox" checked>
            <label for="clearSceneCheckbox">Limpar tela</label>
        </div>

        <div class="avaliable-folders-container p1-all" id="avaliableFoldersContainer"></div>
        <div class="avaliable-clouds-container" id="avaliableCloudsContainer"></div>

        <div class="point-analysis mt-3">
            <h2 class="bg-info p-2 text-white">Análise de ponto</h2>

            <div class="p1-all">
                <div>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="radio" id="pointAnalysisRadiusMethod" name="pointAnalysisMethod" value="radius" checked>
                        <label class="form-check-label" for="pointAnalysisRadiusMethod">
                            Raio
                        </label>
                    </div>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="radio" id="pointAnalysisKMethod" name="pointAnalysisMethod" value="k">
                        <label class="form-check-label" for="pointAnalysisKMethod">
                            K Vizinhos
                        </label>
                    </div>
                </div>

                <div class="input-group input-group-lg">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Valor usado para computar Normal e PC</span>
                    </div>
                    <input type="number" id="pointAnalysisComputationRadiusOrKSize" name="pointAnalysisComputationRadiusOrKSize" value="13" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>

                <div class="btn-group my-3" role="group" aria-label="Buttons">
                    <button id="selectPointButton" class="btn btn-info btn-lg" type="submit">Selecionar ponto</button>
                    <button id="analysisPointButton" class="btn btn-info btn-lg" type="submit">Analisar</button>
                    <button id="downloadButton" class="btn btn-info btn-lg" type="submit">Download</button>
                    <button id="clearPointAnalysis" class="btn btn-danger btn-lg" type="submit">Limpar</button>
                </div>

                <ul class="list-group" id="pointAnalysisResult"></ul>
            </div>
        </div>

        <div class="pipeline-container">
            <h2 class="bg-info p-2 text-white">Filtros</h2>

            <div class="filters-container p1-all">
                <div class="input-group input-group-lg">
                    <input id="filters-input" type="text" class="form-control" list="filters" placeholder="Escolha um filtro.." aria-label="Escolha um filtro.." aria-describedby="basic-addon2">
                    <datalist id="filters">
                        <option value="Shape Index">
                        <option value="Curvatura Gaussiana">
                        <option value="Soma">
                        <option value="Omnivariância">
                        <option value="Autoentropia">
                        <option value="Anisotropia">
                        <option value="Planaridade">
                        <option value="Linearidade">
                        <option value="Esfericidade">
                        <option value="Variação de Superfície">
                        <option value="Verticalidade">
                    </datalist>
                    <div class="input-group-append">
                        <button id="add-filter" class="btn btn-outline-secondary" type="button">Adicionar</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="p1-all">
            <button class="btn btn-info btn-lg" id="performFiltering" type="button">
                Realizar filtragem
                <i class="fas fa-filter"></i>
            </button>
        </div>

        <div class="finducial-points">
            <h2 class="bg-info p-2 text-white">Encontrar ponto fiducial</h2>

            <div class="p1-all">
                <input type="radio" id="nosetip-point" name="fiducial-point" checked>
                <label for="nosetip-point">Ponta do nariz</label>
                <br/>

                <!-- <input type="radio" id="left-right-eye-point" name="fiducial-point">
                <label for="left-right-eye-point">Olho esquerdo/direito (IN PROGRESS)</label>
                <br/>
                <br/> -->

                <input type="checkbox" id="flexibilizeThresholds" name="flexibilizeThresholds" checked>
                <label for="flexibilizeThresholds">Flexibilizar Thresholds:</label>
                <br/>

                <input type="checkbox" id="flexibilizeCrop" name="flexibilizeCrop" checked>
                <label for="flexibilizeCrop">Flexibilizar Crop:</label>

                <div>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="radio" id="radiusMethod" name="computationMethod" value="radius" checked>
                        <label class="form-check-label" for="radiusMethod">
                            Raio
                        </label>
                    </div>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="radio" id="kMethod" name="computationMethod" value="k">
                        <label class="form-check-label" for="kMethod">
                            K Vizinhos
                        </label>
                    </div>
                </div>

                <div class="input-group input-group-lg mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Valor usado para computar Normal e PC</span>
                    </div>
                    <input type="number" id="computationRadiusOrKSize" name="computationRadiusOrKSize" value="13" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>

                <div class="input-group input-group-lg mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">GC mínima</span>
                    </div>
                    <input type="number" id="minGaussianCurvature" name="minGaussianCurvature" value="0.0038" step="0.001" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>

                <div class="input-group input-group-lg mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Limite de SI</span>
                    </div>
                    <input type="number" id="shapeIndexLimit" name="shapeIndexLimit" value="-0.78" step="0.01" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>

                <div class="input-group input-group-lg mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Tamanho de Crop mínimo</span>
                    </div>
                    <input type="number" id="minCropSize" name="minCropSize" value="100" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>

                <div class="input-group input-group-lg mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Tamanho de Crop máximo</span>
                    </div>
                    <input type="number" id="maxCropSize" name="maxCropSize" value="240" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>

                <div class="input-group input-group-lg mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Quantidade mínima de pontos após filtros</span>
                    </div>
                    <input type="number" id="minPointsToContinue" name="minPointsToContinue" value="15" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>

                <div class="input-group input-group-lg mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Raio de busca de pontos isolados</span>
                    </div>
                    <input type="number" id="removeIsolatedPointsRadius" name="removeIsolatedPointsRadius" value="5" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>

                <div class="input-group input-group-lg mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Threshold para pontos isolados</span>
                    </div>
                    <input type="number" id="removeIsolatedPointsThreshold" name="removeIsolatedPointsThreshold" value="6" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>

                <div class="input-group input-group-lg mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Raio para seleção da ponta do nariz</span>
                    </div>
                    <input type="number" id="nosetipSearchRadius" name="nosetipSearchRadius" value="12" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>

                <!-- <label for="sum">Features:</label>
                <br/>

                <input type="checkbox" data-feature name="sum" id="sum" value="Somatório">
                <label for="sum">Somatório</label>
                <br/>

                <input type="checkbox" data-feature name="eigenentropy" id="eigenentropy" value="Autoentropia">
                <label for="eigenentropy">Autoentropia</label>
                <br/>

                <input type="checkbox" data-feature name="anisotropy" id="anisotropy" value="Anisotropia">
                <label for="anisotropy">Anisotropia</label>
                <br/>

                <input type="checkbox" data-feature name="planarity" id="planarity" value="Planaridade">
                <label for="planarity">Planaridade</label>
                <br/>

                <input type="checkbox" data-feature name="linearity" id="linearity" value="Linearidade">
                <label for="linearity">Linearidade</label>
                <br/>

                <input type="checkbox" data-feature name="surface-variation" id="surface-variation" value="Variação de superfı́cie">
                <label for="surface-variation">Variação de superfı́cie</label>
                <br/>

                <input type="checkbox" data-feature name="sphericity" id="sphericity" value="Esfericidade">
                <label for="sphericity">Esfericidade</label>
                <br/>

                <input type="checkbox" data-feature name="verticality" id="verticality" value="Verticalidade">
                <label for="verticality">Verticalidade</label>
                <br/>

                <label for="gfSearchRadius">Raio para filtragem das features da MC:</label>
                <input type="number" id="gfSearchRadius" name="gfSearchRadius" value="10" min="0" step="5" style="width: 80px">
                <br/>

                <label for="featuresThreshold">Threshold para as features da MC:</label>
                <br/>
                <input type="text" id="featuresThreshold" name="featuresThreshold" style="width: 300px" placeholder="valores separados por vírgulas">
                <br>
                <small>*MC (Matriz de covariância)</small>
                <br/>
                <br/> -->

                <div class="mt-2">
                    <button class="btn btn-info btn-lg" id="findFiducialPointButton" type="submit">Encontrar ponto fiducial</button>
                    <button class="btn btn-info btn-lg" id="clearScene" type="submit">Limpar tela</button>
                </div>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>
</body>
<script type="module">
    import * as THREE from './js/pcd-viewer/node_modules/three/build/three.module.js';
    import { PCDLoader } from './js/pcd-viewer/node_modules/three/examples/jsm/loaders/PCDLoader.js';
    import { TrackballControls} from './js/pcd-viewer/node_modules/three/examples/jsm/controls/TrackballControls.js';
    import { GUI } from './js/pcd-viewer/node_modules/three/examples/jsm/libs/dat.gui.module.js';
    import { ColorGUIHelper, SizeGUIHelper } from './js/pcd-viewer/helpers/index.js';

    let fileCounter = 1;
    const center = new THREE.Vector3(0, 0, 0);

    // buttons
    const findFiducialPointButton = document.getElementById('findFiducialPointButton');
    const selectPointButton = document.getElementById('selectPointButton');
    const analysisPointButton = document.getElementById('analysisPointButton');
    const downloadButton = document.getElementById('downloadButton');
    const clearSceneButton = document.getElementById('clearScene');

    // pipeline settings
    const collapsibles = document.querySelectorAll('.custom-collapsible');
    const removeFilters = document.querySelectorAll('.remove-filter');
    const filtersInput = document.getElementById('filters-input');
    const addFilterButton = document.getElementById('add-filter');
    const pipelineContainer = document.querySelector('.pipeline-container')
    const allFilterss = [
        'Shape Index', 'Curvatura Gaussiana', 'Soma', 'Omnivariância', 'Autoentropia', 'Anisotropia',
        'Planaridade', 'Linearidade', 'Esfericidade', 'Variação de Superfície', 'Verticalidade'
    ];
    const avaliableFilters = [];
    const currentFilters = [...avaliableFilters];
    const items = document.querySelectorAll('.pipeline-filter');
    let dragSrcEl = null;
    const performFilteringButton = document.getElementById('performFiltering');
    const filterMap = {
        'Shape Index': {
            name: 'shapeIndex',
            minThreshold: -1,
            maxThreshold: 1
        },
        'Curvatura Gaussiana': {
            name: 'gaussianCurvature',
            minThreshold: 0,
            maxThreshold: 0.02
        },
        'Soma': {
            name: 'sum',
            minThreshold: 0,
            maxThreshold: 100
        },
        'Omnivariância': {
            name: 'omnivariance',
            minThreshold: 1,
            maxThreshold: 1
        },
        'Autoentropia': {
            name: 'eigenentropy',
            minThreshold: -200,
            maxThreshold: 0
        },
        'Anisotropia': {
            name: 'anisotropy',
            minThreshold: 0,
            maxThreshold: 1
        },
        'Planaridade': {
            name: 'planarity',
            minThreshold: 0,
            maxThreshold: 1

        },
        'Linearidade': {
            name: 'linearity',
            minThreshold: 0,
            maxThreshold: 1
        },
        'Esfericidade': {
            name: 'sphericity',
            minThreshold: 0,
            maxThreshold: 1
        },
        'Variação de Superfície': {
            name: 'surfaceVariation',
            minThreshold: 0,
            maxThreshold: 1
        },
        'Verticalidade': {
            name: 'verticality',
            minThreshold: 0,
            maxThreshold: 1
        }
    };

    // checkboxes
    const clearSceneCheckbox = document.getElementById('clearSceneCheckbox');
    const featuresCheckboxes = document.querySelectorAll('input[type="checkbox"][data-feature]');

    // inputs
    const featuresThresholdInput = document.getElementById('featuresThreshold');

    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas });
    const fov = 50; const aspect = 2; const near = 0.1; const far = 10000;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    const mouse = new THREE.Vector2();
    const controls = new TrackballControls(camera, renderer.domElement);
    const scene = new THREE.Scene();

    let intersection = null;
    const pointer = new THREE.Vector2();
    const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

    const inputFile = document.getElementById('pcdInputFile');
    const gui = new GUI();
    const loader = new PCDLoader();

    const raycaster = new THREE.Raycaster();
    const focusRaycaster = new THREE.Raycaster();

    let pcdFile = {};
    let cloudLogFiles = [];
    let runningRaycaster = false;
    let runningFocusRaycaster = false;
    let selectedNosetipCloud = {};
    let pointAnalysis = {};

    function init() {
        loadAvaliableClouds();
        addEventListeners();

        // controls settings
        controls.rotateSpeed = 5.0;
        controls.zoomSpeed = 2;
        controls.panSpeed = 0.5;
        controls.staticMoving = true;

        scene.background = new THREE.Color(0x000000);
        scene.add(new THREE.AmbientLight(0xFFFFFF, 1));
        scene.add(sphere);

        raycaster.params.Points.threshold = 0.5;
        focusRaycaster.params.Points.threshold = 10;

        // disable by default features selection
        document.getElementById('nosetip-point').click();
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
    }

    function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;

        if (needResize) {
            renderer.setSize(width, height, false);
        }

        return needResize;
    }

    function render() {
        if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;

            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
        }

        raycaster.setFromCamera(pointer, camera);

        if (pcdFile.cloud && runningRaycaster) {
            const intersections = raycaster.intersectObjects([pcdFile.cloud]);
            intersection = intersections.length > 0 ? intersections[0] : null;

            if (intersection !== null) {
                sphere.position.copy(intersection.point);
                sphere.scale.set(1, 1, 1);
            }

            sphere.scale.multiplyScalar(0.98);
            sphere.scale.clampScalar(5, 1);
        }

        controls.update();
        renderer.render(scene, camera);
    }

    function addEventListeners() {
        // raycaster selected point
        document.addEventListener('pointermove', onPointerMove);

        // find fiducial point
        findFiducialPointButton.addEventListener('click', () => findFiducialPoint());

        // select point button click
        selectPointButton.addEventListener('click', toggleRaycaster);

        // get point analysis
        analysisPointButton.addEventListener('click', getPointAnalysis)

        // download neighborhood cloud
        downloadButton.addEventListener('click', download);

        [...featuresCheckboxes].forEach(c => c.addEventListener('change', e => {
            e.currentTarget.timeval = new Date().getTime();
        }));

        inputFile.addEventListener('change', () => addPCDFile());

        clearSceneButton.addEventListener('click', cleanScene);

        // document.getElementById('nosetip-point').addEventListener('click', e => {
        //     [...featuresCheckboxes].forEach(c => {
        //         c.disabled = true;
        //         c.classList.add('blocked');
        //     });
        //     featuresThresholdInput.classList.add('blocked');
        //     featuresThresholdInput.disabled = true;
        //     gfSearchRadius.classList.add('blocked');
        //     gfSearchRadius.disabled = true;
        // });

        // document.getElementById('left-right-eye-point').addEventListener('click', e => {
        //     [...featuresCheckboxes].forEach(c => {
        //         c.disabled = false;
        //         c.classList.remove('blocked');
        //     });
        //     featuresThresholdInput.classList.remove('blocked');
        //     featuresThresholdInput.disabled = false;
        //     gfSearchRadius.classList.remove('blocked');
        //     gfSearchRadius.disabled = false;
        // });

        // select point on keydown
        document.addEventListener('keydown', e => {
            if (e.key === 's' || e.key === 'S') {
                toggleRaycaster();
            }
        }, false);

        [...collapsibles].forEach(coll => coll.addEventListener('click', collapse));

        [...removeFilters].forEach(filter => filter.addEventListener('click', removeFilter));

        addFilterButton.addEventListener('click', () => {
            const filterName = filtersInput.value;

            if (!filterName) {
                alert('Filtro não selecionado!');
                return;
            }

            if (currentFilters.includes(filterName)) {
                alert('Filtro já aplicado!');
                return;
            }

            if (!allFilterss.includes(filterName)) {
                alert('Filtro não existe! Por favor, escolha outro.');
                return;
            }

            addFilter(filterName);

            filtersInput.value = '';
        });

        items.forEach(item => { dragAndDropHandlers(item) });

        performFilteringButton.addEventListener('click', applyFiltering);

        avaliableFilters.forEach(filter => {
            setChangeEvents(filter);
        });
    }

    async function applyFilter(e) {
        const filterName = filterMap[this.parentNode.parentNode.parentNode.previousElementSibling.dataset.feature].name;

        const inputFile = document.getElementById(`${filterName}File`);
        if (!inputFile.files[0]) {
            alert('Selecione uma nuvem primeiro!!');
            return;
        }

        let outputFilename = document.getElementById(`${filterName}Filename`).value;
        if (outputFilename && !outputFilename.endsWith('.pcd')) {
            outputFilename += '.pcd';
        }
        const inputUrl = URL.createObjectURL(inputFile.files[0]);
        const sendBlob = await fetch(inputUrl).then(blob => blob.blob());
        const randomFilename = Math.random().toString(36).substring(7) + '.pcd'
        const sendFile = new File([sendBlob], randomFilename);

        const kdtreeMethod = getKDTreeMethod(document, filterName);
        const kdtreeValue = getKDTreeValue(document, filterName);
        const minThreshold = getMinThreshold(document, filterName);
        const maxThreshold = getMaxThreshold(document, filterName);

        const filters = [{
            filterName,
            kdtreeMethod,
            kdtreeValue,
            minThreshold,
            maxThreshold,
        }];

        const formData = new FormData();

        formData.append('file', sendFile);
        formData.append('filters', JSON.stringify(filters));
        formData.append('outputFilename', outputFilename);

        const response = await fetch('http://localhost:3000/filtering', {
            method: 'POST',
            body: formData
        });
        const data = await response.json();

        if (!response.ok) {
            alert('Algum erro aconteceu: ' + data.msg);
            return;
        }

        loadAvaliableClouds();

        const cloud = scene.getObjectByName(filterName);
        scene.remove(cloud);

        const color = document.getElementById(`${filterName}Color`).value;
        const size = document.getElementById(`${filterName}Slider`).value;

        data.intermediary_clouds.forEach(cloudLog => addPointCloudFromCloudLog2(cloudLog, filterName, 0, 150, 1, size, color));
    }

    function addPointCloudFromCloudLog2(cloudLog, label, minSize = 0, maxSize = 150, step = 1, initialPointSize = 2, color = undefined) {
        let materialColor = color;

        if (!color) {
            materialColor = `#${Math.floor(Math.random()*16777215).toString(16)}`;
        }

        const material = new THREE.PointsMaterial({ size: initialPointSize, color: materialColor });
        const points = [];

        cloudLog.cloud.forEach(point => {
            points.push(new THREE.Vector3(point.x, point.y, point.z));
        });

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const newCloud = new THREE.Points(geometry, material);
        newCloud.userData.points = points;
        newCloud.name = label;
        // newCloud.userData.label = label;
        scene.add(newCloud);

        newCloud.geometry.computeBoundingSphere();
        const inputCenter = newCloud.geometry.boundingSphere.center;
        center.x = inputCenter.x;
        center.y = inputCenter.y;
        center.z = inputCenter.z;

        controls.target.set(center.x, center.y, center.z);
        camera.position.set(center.x, center.y, center.z + 200);
        controls.update();

        // const guiColor = gui.addColor(new ColorGUIHelper(newCloud.material, 'color'), 'value').name(cloudLog.cloud_label);
        // const guiSize = gui.add(new SizeGUIHelper(newCloud.material, 'size'), 'value', minSize, maxSize, step).name(cloudLog.cloud_label);

        // cloudLogFiles.push({
        //     cloud: newCloud,
        //     guiColor,
        //     guiSize,
        // })

        // fileCounter += 1;
    }

    function colorHandler(e) {
        const cloud = scene.getObjectByName(e.target.id.slice(0, -5), true);
        if (cloud) {
            cloud.material.color = new THREE.Color(e.target.value);
        }
    }

    function sizeHandler(e) {
        const cloud = scene.getObjectByName(e.target.id.slice(0, -6), true);
        if (cloud) {
            cloud.material.size = e.target.value*.5;
        }
    }

    function toggleVisibilityHandler(e) {
        const cloud = scene.getObjectByName(e.currentTarget.id.slice(0, -4), true);
        if (!cloud) {
            return;
        }

        if (cloud.material.size === 0) {
            cloud.material.size = 2;
            document.getElementById(e.currentTarget.id).firstElementChild.classList.remove('fa-eye-slash');
            document.getElementById(e.currentTarget.id).firstElementChild.classList.add('fa-eye');
            return;
        }

        cloud.material.size = 0;
        document.getElementById(e.currentTarget.id).firstElementChild.classList.remove('fa-eye');
        document.getElementById(e.currentTarget.id).firstElementChild.classList.add('fa-eye-slash');
    }

    function removeCloudFilter(e) {
        const cloud = scene.getObjectByName(e.currentTarget.id.slice(0, -6), true);
        scene.remove(cloud);
    }

    async function applyFiltering() {
        if (!pcdFile.cloud) {
            alert('Selecione uma nuvem primeiro!!');
            return;
        }

        const filtersDivs = document.querySelectorAll('.pipeline-filter');
        const filters = [];

        if (!filtersDivs.length) {
            alert('Nenhum filtro aplicado!!');
            return;
        }

        const inputUrl = pcdFile.blobURL;
        const sendBlob = await fetch(inputUrl).then(blob => blob.blob());
        const randomFilename = Math.random().toString(36).substring(7) + '.pcd'
        const sendFile = new File([sendBlob], randomFilename);

        filtersDivs.forEach(filter => {
            const label = filter.firstElementChild.dataset.feature;
            const filterName = filterMap[label].name;
            const kdtreeMethod = getKDTreeMethod(document, filterName);
            const kdtreeValue = getKDTreeValue(document, filterName);
            const minThreshold = getMinThreshold(document, filterName);
            const maxThreshold = getMaxThreshold(document, filterName);

            // TODO: verificar campos nulos

            // filters.push({
            //     filterName,
            //     params: {
            //         kdtreeMethod,
            //         kdtreeValue,
            //         minThreshold,
            //         maxThreshold
            //     }
            // })

            filters.push({
                filterName,
                kdtreeMethod,
                kdtreeValue,
                minThreshold,
                maxThreshold
            })
        });

        const formData = new FormData();

        formData.append('file', sendFile);
        formData.append('filters', JSON.stringify(filters));

        const response = await fetch('http://localhost:3000/filtering', {
            method: 'POST',
            body: formData
        });
        const data = await response.json();

        if (!response.ok) {
            alert('Algum erro aconteceu: ' + data.msg);
            return;
        }

        data.intermediary_clouds.forEach(cloudLog => addPointCloudFromCloudLog(cloudLog));
    }

    function setChangeEvents(filter) {
        const filterName = filterMap[filter].name;

        document.getElementById(`${filterName}Filename`).addEventListener('change', e => {
            e.target.setAttribute('value', e.target.value);
        });
        document.getElementById(`${filterName}KDTreeMethodRadius`).addEventListener('change', e => {
            e.target.setAttribute('checked', true);
            document.getElementById(`${filterName}KDTreeMethodK`).setAttribute('checked', false);
        });
        document.getElementById(`${filterName}KDTreeMethodK`).addEventListener('change', e => {
            e.target.setAttribute('checked', true);
            document.getElementById(`${filterName}KDTreeMethodRadius`).setAttribute('checked', false);
        });
        document.getElementById(`${filterName}KDTreeValue`).addEventListener('change', e => {
            e.target.setAttribute('value', e.target.value);
        });
        document.getElementById(`${filterName}MinThreshold`).addEventListener('change', e => {
            e.target.setAttribute('value', e.target.value);
        });
        document.getElementById(`${filterName}MaxThreshold`).addEventListener('change', e => {
            e.target.setAttribute('value', e.target.value);
        });
        document.getElementById(`${filterName}Color`).addEventListener('change', e => {
            e.target.setAttribute('value', e.target.value);
        });
        document.getElementById(`${filterName}Slider`).addEventListener('change', e => {
            e.target.setAttribute('value', e.target.value);
        });
    }

    function getKDTreeMethod(document, filterName) {
        return document.getElementById(`${filterName}KDTreeMethodRadius`).checked ? 'radius' : 'k';
    }

    function getKDTreeValue(document, filterName) {
        return document.getElementById(`${filterName}KDTreeValue`).value;
    }

    function getMinThreshold(document, filterName) {
        return document.getElementById(`${filterName}MinThreshold`).value;
    }

    function getMaxThreshold(document, filterName) {
        return document.getElementById(`${filterName}MaxThreshold`).value;
    }

    function addFilter(filter) {
        currentFilters.push(filter);

        const pipelineFilterChild = document.createElement('div');
        pipelineFilterChild.classList.add('pipeline-filter');
        pipelineFilterChild.setAttribute('draggable', true);
        pipelineFilterChild.setAttribute('id', 'draggable');

        const filterName = filterMap[filter].name;
        const minThreshold = filterMap[filter].minThreshold;
        const maxThreshold = filterMap[filter].maxThreshold;

        pipelineFilterChild.innerHTML = `
            <div class="custom-collapsible active" data-feature="${filter}">
                <h2>${filter}</h2>
                <div class="circle">
                <button class="remove-filter">
                    <i class="fas fa-trash trash-icon"></i>
                </button></div>
            </div>
            <div class="custom-collapsible-content" style="display:flex;">
                <div class="input-group mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text">Carregue uma nuvem:</span>
                    </div>
                    <div class="custom-file">
                        <input type="file" class="custom-file-input" id="${filterName}File" name="${filterName}File" accept=".pcd">
                        <label class="custom-file-label" for="${filterName}File">Clique aqui</label>
                    </div>
                </div>
                <div class="input-group input-group-lg mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Nome do arquivo</span>
                    </div>
                    <input type="text" id="${filterName}Filename" name="${filterName}Filename" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>
                <h3 class="my-1">Método para calcular a vizinhança</h3>
                <div>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="radio" id="${filterName}KDTreeMethodRadius" name="${filterName}KDTreeMethod" value="radius" checked>
                        <label class="form-check-label" for="${filterName}KDTreeMethodRadius">Raio</label>
                    </div>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="radio" id="${filterName}KDTreeMethodK" name="${filterName}KDTreeMethod" value="k">
                        <label class="form-check-label" for="${filterName}KDTreeMethodK">K Vizinhos</label>
                    </div>
                </div>
                <div class="input-group input-group-lg mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Valor para calcular a vizinhança</span>
                    </div>
                    <input type="number" id="${filterName}KDTreeValue" name="${filterName}KDTreeValue" value="10" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>
                <div class="input-group input-group-lg mb-2">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Threshold mínimo</span>
                    </div>
                    <input type="number" id="${filterName}MinThreshold" name="${filterName}MinThreshold" value="${minThreshold}" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>
                <div class="input-group input-group-lg">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="inputGroup-sizing-lg">Threshold mínimo</span>
                    </div>
                    <input type="number" id="${filterName}MaxThreshold" name="${filterName}MaxThreshold" value="${maxThreshold}" class="form-control" aria-label="Large" aria-describedby="inputGroup-sizing-sm">
                </div>
                <div class="d-flex mt-2 justify-content-between align-items-center w-100">
                    <div class="d-flex align-items-center">
                        <label for="${filterName}Color" class="form-label">Cor:</label>
                        <input type="color" class="form-control form-control-color mx-2" role="button" id="${filterName}Color" value="#e66465" title="Escolhar a cor da nuvem">
                        <label for="${filterName}Slider" class="form-label">Tamanho:</label>
                        <input type="number" min="0" max="10" class="form-control form-control mx-2" id="${filterName}Slider" value="2" title="Escolhar o tamanho dos pontos da nuvem">
                    </div>
                    <div class="d-flex align-items-center">
                        <button class="btn btn-success" id="${filterName}Filter" title="Filtrar">
                            <i class="fas fa-play"></i>
                        </button>
                        <button class="btn btn-secondary mx-2" id="${filterName}Hide" title="Show/hide">
                            <i class="far fa-eye"></i>
                        </button>
                        <button class="btn btn-danger" id="${filterName}Remove" title="Remover nuvem">
                            <i class="fas fa-minus-circle"></i>
                        </button>
                    </div>
                </div>
            </div>
        `;

        dragAndDropHandlers(pipelineFilterChild);
        pipelineFilterChild.firstElementChild.addEventListener('click', collapse);
        pipelineFilterChild.firstElementChild.lastElementChild.addEventListener('click', removeFilter);
        pipelineContainer.appendChild(pipelineFilterChild);
        setChangeEvents(filter);
        setFilterCardEvents(filter);
    }

    document.getElementById('clearPointAnalysis').addEventListener('click', e => {
        document.getElementById('pointAnalysisResult').innerHTML = '';
        e.target.style.display = 'none';
    });

    function setFilterCardEvents(filter) {
        const filterName = filterMap[filter].name;

        document.getElementById(`${filterName}Filter`).addEventListener('click', applyFilter);
        document.getElementById(`${filterName}Color`).addEventListener('change', colorHandler);
        document.getElementById(`${filterName}Slider`).addEventListener('change', sizeHandler);
        document.getElementById(`${filterName}Remove`).addEventListener('click', removeCloudFilter);
        document.getElementById(`${filterName}Hide`).addEventListener('click', toggleVisibilityHandler);
    }

    function collapse() {
        this.classList.toggle('active');

        const content = this.nextElementSibling;

        if (content.style.display === 'flex') {
            content.style.display = 'none';
        } else {
            content.style.display = 'flex';
        }
    }

    function removeFilter(e) {
        e.stopPropagation();
        currentFilters.splice(currentFilters.indexOf(this.previousElementSibling.innerHTML), 1);
        document.querySelector(`div[data-feature="${this.parentNode.dataset.feature}"]`).parentNode.remove();
        const cloud = scene.getObjectByName(filterMap[this.parentNode.dataset.feature].name, true);
        scene.remove(cloud);
    }

    function handleDragStart(e) {
        this.style.opacity = '0.4';

        dragSrcEl = this;

        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', this.innerHTML);
    }

    function handleDragEnd(e) {
        this.style.opacity = '1';

        items.forEach(function (item) {
            item.classList.remove('over');
        });
    }

    function handleDragOver(e) {
        if (e.preventDefault) {
            e.preventDefault();
        }

        e.dataTransfer.dropEffect = 'move';

        return false;
    }

    function handleDragEnter(e) {
        this.classList.add('over');
    }

    function handleDragLeave(e) {
        this.classList.remove('over');
    }

    function handleDrop(e) {
        e.stopPropagation();

        if (dragSrcEl !== this) {
            dragSrcEl.innerHTML = this.innerHTML;
            this.innerHTML = e.dataTransfer.getData('text/html');

            // button to remove filters
            this.firstElementChild.lastElementChild.addEventListener('click', removeFilter);
            dragSrcEl.firstElementChild.lastElementChild.addEventListener('click', removeFilter);

            // attach collapse event
            this.firstElementChild.addEventListener('click', collapse);
            dragSrcEl.firstElementChild.addEventListener('click', collapse);

            const thisFilterName = this.firstElementChild.dataset.feature;
            const dragSrcElFilterName = dragSrcEl.firstElementChild.dataset.feature;

            setChangeEvents(thisFilterName);
            setChangeEvents(dragSrcElFilterName);
            setFilterCardEvents(thisFilterName);
            setFilterCardEvents(dragSrcElFilterName);
        }

        return false;
    }

    function dragAndDropHandlers(item) {
        item.addEventListener('dragstart', handleDragStart, false);
        item.addEventListener('dragenter', handleDragEnter, false);
        item.addEventListener('dragover', handleDragOver, false);
        item.addEventListener('dragleave', handleDragLeave, false);
        item.addEventListener('drop', handleDrop, false);
        item.addEventListener('dragend', handleDragEnd, false);
    }

    // Event Lisntener Functions

    function addPCDFile(blobURL = undefined, cloudName = undefined) {
        let inputUrl = '';
        let filename = '';

        if (blobURL) {
            inputUrl = blobURL;
            filename = cloudName;
        } else {
            inputUrl = URL.createObjectURL(inputFile.files[0]);
            filename = inputFile.files[0].name;
        }

        if (inputUrl) {
            loader.load(inputUrl, pointCloud => {
                if (clearSceneCheckbox.checked) {
                    cleanScene();
                }

                pointCloud.material.size = 0.8;
                scene.add(pointCloud);

                const inputCenter = pointCloud.geometry.boundingSphere.center;
                center.x = inputCenter.x;
                center.y = inputCenter.y;
                center.z = inputCenter.z;

                controls.target.set(center.x, center.y, center.z);
                camera.position.set(center.x, center.y, center.z + 200);
                controls.update();

                const guiColor = gui.addColor(new ColorGUIHelper(pointCloud.material, 'color'), 'value').name(`Color ${fileCounter}`);
                const guiSize = gui.add(new SizeGUIHelper(pointCloud.material, 'size'), 'value', 0, 150, 1).name(`Size ${fileCounter}`);

                fileCounter += 1;
                pcdFile = {
                    cloud: pointCloud,
                    blobURL: inputUrl,
                    filename,
                    guiColor,
                    guiSize,
                };
            });
        }
    }

    async function findFiducialPoint() {
        if (!pcdFile.cloud) {
            alert('Selecione uma nuvem primeiro!!');
            return;
        }

        const fiducialPoint = document.getElementById('nosetip-point').checked ? 'nosetip' : 'eye';

        const features = [...featuresCheckboxes]
            .filter(c => c.checked)
            .sort((a, b) => a.timeval - b.timeval)
            .map(f => f.value).join(',');

        if (fiducialPoint === 'eye' && !features) {
            alert('Selecione alguma feature!');
            return;
        }

        // const featuresThreshold = featuresThresholdInput.value.replace(/(^,)|(,$)/g, '');

        // if (features.split(',').filter(Boolean).length !== featuresThreshold.split(',').filter(Boolean).length) {
        //     alert('Número de features e thresholds devem ser iguais.');
        //     return;
        // }

        cleanCloudLogEntries();
        cleanPointAnalysis();

        const inputUrl = pcdFile.blobURL;
        const sendBlob = await fetch(inputUrl).then(blob => blob.blob());
        const randomFilename = Math.random().toString(36).substring(7) + '.pcd'
        const sendFile = new File([sendBlob], randomFilename);

        const flexibilizeThresholds = document.getElementById('flexibilizeThresholds');
        const flexibilizeCrop = document.getElementById('flexibilizeCrop');
        const computationRadiusOrKSize = document.getElementById('computationRadiusOrKSize');
        const computationMethod = document.getElementById('radiusMethod').checked ? 'radius' : 'k';
        const minGaussianCurvature = document.getElementById('minGaussianCurvature');
        const shapeIndexLimit = document.getElementById('shapeIndexLimit');
        const minCropSize = document.getElementById('minCropSize');
        const maxCropSize = document.getElementById('maxCropSize');
        const minPointsToContinue = document.getElementById('minPointsToContinue');
        const removeIsolatedPointsRadius = document.getElementById('removeIsolatedPointsRadius');
        const removeIsolatedPointsThreshold = document.getElementById('removeIsolatedPointsThreshold');
        const nosetipSearchRadius = document.getElementById('nosetipSearchRadius');
        // const gfSearchRadius = document.getElementById('gfSearchRadius');

        const formData = new FormData();

        formData.append('flexibilizeThresholds', flexibilizeThresholds.checked);
        formData.append('flexibilizeCrop', flexibilizeCrop.checked);
        formData.append('computationRadiusOrKSize', computationRadiusOrKSize.value);
        formData.append('computationMethod', computationMethod);
        formData.append('minGaussianCurvature', minGaussianCurvature.value);
        formData.append('shapeIndexLimit', shapeIndexLimit.value);
        formData.append('minCropSize', minCropSize.value);
        formData.append('maxCropSize', maxCropSize.value);
        formData.append('minPointsToContinue', minPointsToContinue.value);
        formData.append('removeIsolatedPointsRadius', removeIsolatedPointsRadius.value);
        formData.append('removeIsolatedPointsThreshold', removeIsolatedPointsThreshold.value);
        formData.append('nosetipSearchRadius', nosetipSearchRadius.value);
        // formData.append('gfSearchRadius', gfSearchRadius.value);
        // formData.append('features', features);
        // formData.append('featuresThreshold', featuresThreshold);
        formData.append('fiducialPoint', fiducialPoint);
        formData.append('file', sendFile);

        const response = await fetch('http://localhost:3000/find-fiducial-point', {
            method: 'POST',
            body: formData
        });
        const data = await response.json();

        if (!response.ok) {
            alert('Algum erro ocorreu: ' + data.msg);

            return;
        }

        data.intermediary_clouds.forEach(cloudLog => addPointCloudFromCloudLog(cloudLog));

        const fiducialPointCloudLog = {
            cloud_label: 'Fiducial Point',
            cloud: [{ x: data.point.x, y: data.point.y, z: data.point.z }]
        };

        addPointCloudFromCloudLog(fiducialPointCloudLog, 150, 400, 1, 4, '#FFFFFF');
    }

    async function getPointAnalysis() {
        if (!selectedNosetipCloud || (Object.keys(selectedNosetipCloud).length === 0 && selectedNosetipCloud.constructor === Object)) {
            alert('Selecione um ponto antes de realizar sua análise');
            return;
        }

        const inputUrl = pcdFile.blobURL;
        const sendBlob = await fetch(inputUrl).then(blob => blob.blob());
        const randomFilename = Math.random().toString(36).substring(7) + '.pcd'
        const sendFile = new File([sendBlob], randomFilename);

        const method = document.getElementById('pointAnalysisRadiusMethod').checked ? 'radius' : 'k';
        const pointAnalysisComputationRadiusOrKSize = document.getElementById('pointAnalysisComputationRadiusOrKSize');

        const formData = new FormData();

        formData.append('file', sendFile);
        formData.append('computationMethod', method);
        formData.append('computationSize', pointAnalysisComputationRadiusOrKSize.value);
        formData.append('pointIndexToAnalyze', selectedNosetipCloud.index);

        const response = await fetch('http://localhost:3000/point-analysis', {
            method: 'POST',
            body: formData
        });
        const data = await response.json();

        if (!response.ok) {
            alert('Algum erro ocorreu: ' + data.msg);

            return;
        }

        insertPointAnalysisOnHTML(data.point_analysis);

        const cloudLog = {
            cloud_label: 'Neighborhood',
            cloud: data.point_analysis.neighborhood
        };

        addPointCloudFromCloudLog(cloudLog);
    }

    function onPointerMove(event) {
        pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
    }

    function toggleRaycaster() {
        if (runningRaycaster) {
            scene.remove(sphere);
            canvas.removeEventListener('click', runRaycast);
        } else {
            scene.add(sphere);
            canvas.addEventListener('click', runRaycast);
        }

        runningRaycaster = !runningRaycaster;
    }

    function runRaycast(e) {
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObject(pcdFile.cloud);

        if (intersects.length) {
            cleanSelectedNosetipCloud();
            cleanPointAnalysis();

            const newColor = new THREE.Color();
            newColor.setRGB(1, 1, 1);

            const index = intersects[0].index;

            toggleRaycaster();

            const material = new THREE.PointsMaterial({ size: 1.5, color: '#FFFFFF' });

            const point = {
                x: pcdFile.cloud.geometry.getAttribute('position').getX(index),
                y: pcdFile.cloud.geometry.getAttribute('position').getY(index),
                z: pcdFile.cloud.geometry.getAttribute('position').getZ(index)
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(
                [new THREE.Vector3(point.x, point.y, point.z)]
            );

            const newCloud = new THREE.Points(geometry, material);
            scene.add(newCloud);

            const guiColor = gui.addColor(new ColorGUIHelper(newCloud.material, 'color'), 'value').name(`Selected point ${fileCounter}`);
            const guiSize = gui.add(new SizeGUIHelper(newCloud.material, 'size'), 'value', 150, 400, 1).name(`Selected point ${fileCounter}`);

            selectedNosetipCloud = {
                cloud: newCloud,
                point,
                index,
                guiColor,
                guiSize
            }

            fileCounter += 1;
        }
    }

    function toggleFocusRaycaster(e) {
        if (runningFocusRaycaster) {
            canvas.removeEventListener('click', focusOnNewPoint);
        } else {
            canvas.addEventListener('click', focusOnNewPoint);
        }

        runningFocusRaycaster = !runningFocusRaycaster;
    }

    function insertPointAnalysisOnHTML(pointAnalysis) {
        document.getElementById('pointAnalysisResult').innerHTML = `
            <li class="list-group-item"><span class="font-weight-bold">Point (x, y, z):</span> (${selectedNosetipCloud.point.x.toFixed(5)}, ${selectedNosetipCloud.point.y.toFixed(5)}, ${selectedNosetipCloud.point.z.toFixed(5)})</li>
            <li class="list-group-item"><span class="font-weight-bold">Número de pontos:</span> ${pointAnalysis.neighborhood.length}</li>
            <li class="list-group-item"><span class="font-weight-bold">Gaussian Curvature:</span> ${pointAnalysis.gaussian_curvature.toFixed(5)}</li>
            <li class="list-group-item"><span class="font-weight-bold">Shape Index:</span> ${pointAnalysis.shape_index.toFixed(5)}</li>
            <li class="list-group-item"><span class="font-weight-bold">Normal (x, y, z):</span> (${pointAnalysis.normal.x.toFixed(5)}, ${pointAnalysis.normal.y.toFixed(5)}, ${pointAnalysis.normal.z.toFixed(5)})</li>
            <li class="list-group-item"><span class="font-weight-bold">PCs (k1, k2):</span> (${pointAnalysis.principal_curvatures.k1.toFixed(5)}, ${pointAnalysis.principal_curvatures.k2.toFixed(5)})</li>
            <li class="list-group-item"><span class="font-weight-bold">Soma:</span> ${pointAnalysis.geometric_features.sum.toFixed(5)}</li>
            <li class="list-group-item"><span class="font-weight-bold">Omnivariância:</span> ${pointAnalysis.geometric_features.omnivariance.toFixed(5)}</li>
            <li class="list-group-item"><span class="font-weight-bold">Autoentropia:</span> ${pointAnalysis.geometric_features.eigenentropy.toFixed(5)}</li>
            <li class="list-group-item"><span class="font-weight-bold">Anisotropia:</span> ${pointAnalysis.geometric_features.anisotropy.toFixed(5)}</li>
            <li class="list-group-item"><span class="font-weight-bold">Planaridade:</span> ${pointAnalysis.geometric_features.planarity.toFixed(5)}</li>
            <li class="list-group-item"><span class="font-weight-bold">Linearidade:</span> ${pointAnalysis.geometric_features.linearity.toFixed(5)}</li>
            <li class="list-group-item"><span class="font-weight-bold">Variação de superfície:</span> ${pointAnalysis.geometric_features.surfaceVariation.toFixed(5)}</li>
            <li class="list-group-item"><span class="font-weight-bold">Esfericidade:</span> ${pointAnalysis.geometric_features.sphericity.toFixed(5)}</li>
            <li class="list-group-item"><span class="font-weight-bold">Verticalidade:</span> ${pointAnalysis.geometric_features.verticality.toFixed(5)}</li>
        `;
        document.getElementById('clearPointAnalysis').style.display = 'inline-block';
    }

    function addPointCloudFromCloudLog(cloudLog, minSize = 0, maxSize = 150, step = 1, initialPointSize = 2, color = undefined) {
        let materialColor = color;

        if (!color) {
            materialColor = `#${Math.floor(Math.random()*16777215).toString(16)}`;
        }

        const material = new THREE.PointsMaterial({ size: initialPointSize, color: materialColor });
        const points = [];

        cloudLog.cloud.forEach(point => {
            points.push(new THREE.Vector3(point.x, point.y, point.z));
        });

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const newCloud = new THREE.Points(geometry, material);
        newCloud.userData.points = points;
        newCloud.name = 'neighborhood';
        scene.add(newCloud);

        if (!pcdFile || (Object.keys(pcdFile).length === 0 && pcdFile.constructor === Object)) {
            newCloud.geometry.computeBoundingSphere();
            const inputCenter = newCloud.geometry.boundingSphere.center;
            center.x = inputCenter.x;
            center.y = inputCenter.y;
            center.z = inputCenter.z;

            controls.target.set(center.x, center.y, center.z);
            controls.update();
        }

        const guiColor = gui.addColor(new ColorGUIHelper(newCloud.material, 'color'), 'value').name(cloudLog.cloud_label);
        const guiSize = gui.add(new SizeGUIHelper(newCloud.material, 'size'), 'value', minSize, maxSize, step).name(cloudLog.cloud_label);

        cloudLogFiles.push({
            cloud: newCloud,
            guiColor,
            guiSize,
        })

        fileCounter += 1;
    }

    function download() {
        if (!selectedNosetipCloud.point) {
            return;
        }

        const saveData = (function () {
            const a = document.createElement('a');
            document.body.appendChild(a);
            a.style = 'display: none';
            return (data, fileName) => {
                const blob = new Blob([data], { type: 'octet/stream' });
                const url = window.URL.createObjectURL(blob);
                a.href = url;
                a.download = fileName;
                a.click();
                window.URL.revokeObjectURL(url);
            };
        }());

        const cloud = scene.getObjectByName('neighborhood', true);

        let baseFile = '# .PCD v0.7 - Point Cloud Data file format\nVERSION 0.7\nFIELDS x y z\nSIZE 4 4 4\nTYPE F F F\nCOUNT 1 1 1\nWIDTH 1\nHEIGHT 1\nVIEWPOINT 0 0 0 1 0 0 0\nPOINTS 1\nDATA ascii\n';
        baseFile = baseFile + `${selectedNosetipCloud.point.x} ${selectedNosetipCloud.point.y} ${selectedNosetipCloud.point.z}\n`;

        const points = cloud.userData.points;
        for (let i = 0; i < points.length; i++) {
            baseFile += `${points[i].x} ${points[i].y} ${points[i].z}\n`
        }

        saveData(baseFile, `point_selected_${pcdFile.filename}`);
    }

    function cleanPointAnalysis() {
        document.getElementById('pointAnalysisResult').innerHTML = '';
    }

    function cleanSelectedNosetipCloud() {
        if ('cloud' in selectedNosetipCloud && selectedNosetipCloud.cloud) {
            scene.remove(selectedNosetipCloud.cloud);
            delete selectedNosetipCloud.cloud;
        }

        if ('guiColor' in selectedNosetipCloud && selectedNosetipCloud.guiColor) {
            gui.remove(selectedNosetipCloud.guiColor);
            delete selectedNosetipCloud.guiColor;
        }

        if ('guiSize' in selectedNosetipCloud && selectedNosetipCloud.guiSize) {
            gui.remove(selectedNosetipCloud.guiSize);
            delete selectedNosetipCloud.guiSize;
        }

        selectedNosetipCloud = {};
        cleanPointAnalysis();
    }

    function cleanCloudLogEntries() {
        for (let i = 0; i < cloudLogFiles.length; i++) {
            const c = cloudLogFiles[i];

            scene.remove(c.cloud);
            gui.remove(c.guiColor);
            gui.remove(c.guiSize);
        }

        cloudLogFiles = [];
    }

    function cleanPCDFile() {
        if ('cloud' in pcdFile && pcdFile.cloud) {
            scene.remove(pcdFile.cloud);
        }

        if ('guiColor' in pcdFile && pcdFile.guiColor) {
            gui.remove(pcdFile.guiColor);
        }

        if ('guiSize' in pcdFile && pcdFile.guiSize) {
            gui.remove(pcdFile.guiSize);
        }

        pcdFile = {};
    }

    function cleanScene() {
        cleanPCDFile();
        cleanSelectedNosetipCloud();
        cleanCloudLogEntries();
    }

    function focusOnNewPoint(e) {
        mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;

        focusRaycaster.setFromCamera(mouse, camera);

        const intersects = focusRaycaster.intersectObject(pcdFile.cloud);

        if (intersects.length) {
            const index = intersects[0].index;

            const point = {
                x: pcdFile.cloud.geometry.getAttribute('position').getX(index),
                y: pcdFile.cloud.geometry.getAttribute('position').getY(index),
                z: pcdFile.cloud.geometry.getAttribute('position').getZ(index)
            }

            controls.target.set( point.x, point.y, point.z );
            camera.position.set( point.x, point.y, point.z + 50 );
            controls.update();

            toggleFocusRaycaster();
        }
    }

    function loadAvaliableClouds() {
        fetch('http://localhost:3000/avaliable-clouds', { method: 'GET' }).then((response) => {
            response.json().then(res => {
                setAvaliableFoldersHTML(res);
            })
        });
    }

    function setAvaliableFoldersHTML(folders) {
        const avaliableFoldersContainer = document.getElementById('avaliableFoldersContainer');
        avaliableFoldersContainer.innerHTML = '';

        for (let folder in folders) {
            const folderContainer = document.createElement('div');

            folderContainer.classList.add('avaliable-folder', 'badge' ,'badge-secondary');
            folderContainer.id = 'folder-' + folder;
            folderContainer.innerText = folder;

            folderContainer.addEventListener('click', () => {
                setAvaliableCloudsHTML(folder, folders[folder]);
            });

            avaliableFoldersContainer.appendChild(folderContainer);
        }

        document.getElementById(`folder-${Object.keys(folders)[0]}`).click();
    }

    function setAvaliableCloudsHTML(folder, clouds) {
        const avaliableCloudsContainer = document.getElementById('avaliableCloudsContainer');
        avaliableCloudsContainer.innerHTML = '';

        for (let cloud of clouds) {
            const button = document.createElement('button');
            button.type = 'submit';
            button.id = 'load-button-' + cloud;
            button.innerHTML = 'Carregar';
            button.classList.add('btn', 'btn-secondary', 'btn-lg');

            const label = document.createElement('label');
            label.for = 'load-button-' + cloud;
            label.id = 'label-' + cloud;
            label.innerText = cloud;

            button.addEventListener('click', () => {
                fetch(`http://localhost:3000/avaliable-clouds/${folder}/${cloud}`, { method: 'GET' }).then((response) => {
                    response.blob().then((res) => {
                        const pcdBlob = URL.createObjectURL(res);
                        addPCDFile(pcdBlob, cloud);
                    })
                });
            });

            const div = document.createElement('div');
            div.classList.add('load-cloud-button-container');

            div.appendChild(button);
            div.append(label);

            avaliableCloudsContainer.appendChild(div);
        }
    }

    // jquery helpers
    $(document).on('change', '.custom-file-input', function (event) {
        $(this).next('.custom-file-label').html(event.target.files[0].name);
    });

    init();
    animate();
</script>
<script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
</html>
