<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LATIN PCD Viewer</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="sidemenu">
        <div class="load-image p1-all">
            <label for="pcdInputFile">Carregue uma nuvem:</label>
            <input type="file" id="pcdInputFile" name="pcdInputFile" accept=".pcd">
            <br/>
            <br/>

            <input id="clearSceneCheckbox" type="checkbox" checked>
            <label for="clearSceneCheckbox">Limpar tela</label>
        </div>

        <div class="separator"></div>

        <div class="avaliable-folders-container p1-all" id="avaliableFoldersContainer"></div>
        <div class="avaliable-clouds-container" id="avaliableCloudsContainer"></div>

        <div class="separator"></div>

        <div class="point-analysis p1-all">
            <h4>Análise de ponto</h4>

            <label for="pointAnalysisRadiusMethod">Método de computação:</label>
            <input type="radio" id="pointAnalysisRadiusMethod" name="pointAnalysisMethod" value="radius" checked>
            <label for="pointAnalysisRadiusMethod">Raio</label>
            <input type="radio" id="pointAnalysisKMethod" name="pointAnalysisMethod" value="k">
            <label for="pointAnalysisKMethod">K Vizinhos</label>
            <br/>

            <label for="pointAnalysisComputationRadiusOrKSize">Valor usado para computar Normal e PC:</label>
            <input type="number" id="pointAnalysisComputationRadiusOrKSize" name="pointAnalysisComputationRadiusOrKSize" value="13" style="width: 80px">
            <br/>

            <input id="selectPointButton" style="margin-top: 10px;" type="submit" value="Selecionar ponto">
            <input id="analysisPointButton" style="margin-top: 10px;" type="submit" value="Analisar">
            <input id="downloadButton" style="margin-top: 10px;" type="submit" value="Download">
            <div id="pointAnalysisResult"></div>
        </div>

        <div class="separator"></div>

        <div class="finducial-points p1-all">
            <h4>Encontrar ponto fiducial</h4>

            <input type="radio" id="nosetip-point" name="fiducial-point" checked>
            <label for="nosetip-point">Ponta do nariz</label>
            <br/>

            <input type="radio" id="left-right-eye-point" name="fiducial-point">
            <label for="left-right-eye-point">Olho esquerdo/direito (IN PROGRESS)</label>
            <br/>
            <br/>

            <input type="checkbox" id="flexibilizeThresholds" name="flexibilizeThresholds" checked>
            <label for="flexibilizeThresholds">Flexibilizar Thresholds:</label>
            <br/>

            <input type="checkbox" id="flexibilizeCrop" name="flexibilizeCrop" checked>
            <label for="flexibilizeCrop">Flexibilizar Crop:</label>
            <br/>
            <br/>

            <label for="radiusMethod">Método de computação:</label>
            <input type="radio" id="radiusMethod" name="computationMethod" value="radius" checked>
            <label for="radiusMethod">Raio</label>
            <input type="radio" id="kMethod" name="computationMethod" value="k">
            <label for="kMethod">K Vizinhos</label>
            <br/>

            <label for="computationRadiusOrKSize">Valor usado para computar Normal e PC:</label>
            <input type="number" id="computationRadiusOrKSize" name="computationRadiusOrKSize" value="13" style="width: 80px">
            <br/>

            <label for="minGaussianCurvature">GC mínima</label>
            <input type="number" id="minGaussianCurvature" name="minGaussianCurvature" value="0.0038" step="0.001">
            <br/>

            <label for="shapeIndexLimit">Limite de SI:</label>
            <input type="number" id="shapeIndexLimit" name="shapeIndexLimit" value="-0.78" step="0.01" style="width: 80px">
            <br/>

            <label for="minCropSize">Tamanho de Crop mínimo:</label>
            <input type="number" id="minCropSize" name="minCropSize" value="100" style="width: 80px">
            <br/>

            <label for="maxCropSize">Tamanho de Crop máximo:</label>
            <input type="number" id="maxCropSize" name="maxCropSize" value="240" style="width: 80px">
            <br/>

            <label for="minPointsToContinue">Quantidade mínima de pontos após filtros:</label>
            <input type="number" id="minPointsToContinue" name="minPointsToContinue" value="15" style="width: 80px">
            <br/>

            <label for="removeIsolatedPointsRadius">Raio de busca de pontos isolados:</label>
            <input type="number" id="removeIsolatedPointsRadius" name="removeIsolatedPointsRadius" value="5" style="width: 80px">
            <br/>

            <label for="removeIsolatedPointsThreshold">Threshold para pontos isolados:</label>
            <input type="number" id="removeIsolatedPointsThreshold" name="removeIsolatedPointsThreshold" value="6" style="width: 80px">
            <br/>

            <label for="nosetipSearchRadius">Raio para seleção da ponta do nariz:</label>
            <input type="number" id="nosetipSearchRadius" name="nosetipSearchRadius" value="12" style="width: 80px">
            <br/>

            <label for="sum">Features:</label>
            <br/>

            <input type="checkbox" data-feature name="sum" id="sum" value="Somatório">
            <label for="sum">Somatório</label>
            <br/>

            <input type="checkbox" data-feature name="eigenentropy" id="eigenentropy" value="Autoentropia">
            <label for="eigenentropy">Autoentropia</label>
            <br/>

            <input type="checkbox" data-feature name="anisotropy" id="anisotropy" value="Anisotropia">
            <label for="anisotropy">Anisotropia</label>
            <br/>

            <input type="checkbox" data-feature name="planarity" id="planarity" value="Planaridade">
            <label for="planarity">Planaridade</label>
            <br/>

            <input type="checkbox" data-feature name="linearity" id="linearity" value="Linearidade">
            <label for="linearity">Linearidade</label>
            <br/>

            <input type="checkbox" data-feature name="surface-variation" id="surface-variation" value="Variação de superfı́cie">
            <label for="surface-variation">Variação de superfı́cie</label>
            <br/>

            <input type="checkbox" data-feature name="sphericity" id="sphericity" value="Esfericidade">
            <label for="sphericity">Esfericidade</label>
            <br/>

            <input type="checkbox" data-feature name="verticality" id="verticality" value="Verticalidade">
            <label for="verticality">Verticalidade</label>
            <br/>

            <label for="gfSearchRadius">Raio para filtragem das features da MC:</label>
            <input type="number" id="gfSearchRadius" name="gfSearchRadius" value="10" min="0" step="5" style="width: 80px">
            <br/>

            <label for="featuresThreshold">Threshold para as features da MC:</label>
            <br/>
            <input type="text" id="featuresThreshold" name="featuresThreshold" style="width: 300px" placeholder="valores separados por vírgulas">
            <br>
            <small>*MC (Matriz de covariância)</small>
            <br/>
            <br/>

            <input id="findFiducialPointButton" type="submit" value="Encontrar ponto fiducial">
            <input id="clearScene" type="submit" value="Limpar tela">
            <br/>
        </div>
    </div>

    <canvas id="canvas"></canvas>
</body>
<script type="module">
    import * as THREE from './js/pcd-viewer/node_modules/three/build/three.module.js';
    import { PCDLoader } from './js/pcd-viewer/node_modules/three/examples/jsm/loaders/PCDLoader.js';
    import { TrackballControls} from './js/pcd-viewer/node_modules/three/examples/jsm/controls/TrackballControls.js';
    import { GUI } from './js/pcd-viewer/node_modules/three/examples/jsm/libs/dat.gui.module.js';
    import { ColorGUIHelper, SizeGUIHelper } from './js/pcd-viewer/helpers/index.js';

    let fileCounter = 1;
    const center = new THREE.Vector3(0, 0, 0);

    // buttons
    const findFiducialPointButton = document.getElementById('findFiducialPointButton');
    const selectPointButton = document.getElementById('selectPointButton');
    const analysisPointButton = document.getElementById('analysisPointButton');
    const downloadButton = document.getElementById('downloadButton');
    const clearSceneButton = document.getElementById('clearScene');

    // checkboxes
    const clearSceneCheckbox = document.getElementById('clearSceneCheckbox');
    const featuresCheckboxes = document.querySelectorAll('input[type="checkbox"][data-feature]');

    // inputs
    const featuresThresholdInput = document.getElementById('featuresThreshold');

    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas });
    const fov = 50; const aspect = 2; const near = 0.1; const far = 10000;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    const mouse = new THREE.Vector2();
    const controls = new TrackballControls(camera, renderer.domElement);
    const scene = new THREE.Scene();

    let intersection = null;
    const pointer = new THREE.Vector2();
    const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

    const inputFile = document.getElementById('pcdInputFile');
    const gui = new GUI();
    const loader = new PCDLoader();

    const raycaster = new THREE.Raycaster();
    const focusRaycaster = new THREE.Raycaster();

    let pcdFile = {};
    let cloudLogFiles = [];
    let runningRaycaster = false;
    let runningFocusRaycaster = false;
    let selectedNosetipCloud = {};
    let pointAnalysis = {};

    function init() {
        loadAvaliableClouds();
        addEventListeners();

        // controls settings
        controls.rotateSpeed = 5.0;
        controls.zoomSpeed = 2;
        controls.panSpeed = 0.5;
        controls.staticMoving = true;

        scene.background = new THREE.Color(0x000000);
        scene.add(new THREE.AmbientLight(0xFFFFFF, 1));
        scene.add(sphere);

        raycaster.params.Points.threshold = 0.5;
        focusRaycaster.params.Points.threshold = 10;

        // disable by default features selection
        document.getElementById('nosetip-point').click();

        function loadAvaliableClouds() {
            fetch('http://localhost:3000/avaliable-clouds', { method: 'GET' }).then((response) => {
                response.json().then(res => {
                    setAvaliableFoldersHTML(res);
                })
            });
        }

        function setAvaliableFoldersHTML(folders) {
            const avaliableFoldersContainer = document.getElementById('avaliableFoldersContainer');

            for (let folder in folders) {
                const folderContainer = document.createElement('div');

                folderContainer.classList.add('avaliable-folder');
                folderContainer.id = 'folder-' + folder;
                folderContainer.innerText = folder;

                folderContainer.addEventListener('click', () => {
                    setAvaliableCloudsHTML(folder, folders[folder]);
                });

                avaliableFoldersContainer.appendChild(folderContainer);
            }

            document.getElementById(`folder-${Object.keys(folders)[0]}`).click();
        }

        function setAvaliableCloudsHTML(folder, clouds) {
            const avaliableCloudsContainer = document.getElementById('avaliableCloudsContainer');
            avaliableCloudsContainer.innerHTML = '';

            for (let cloud of clouds) {
                const input = document.createElement('input');
                input.type = 'submit';
                input.id = 'load-input-' + cloud;
                input.value = 'Carregar';

                const label = document.createElement('label');
                label.for = 'load-input-' + cloud;
                label.id = 'label-' + cloud;
                label.innerText = cloud;

                input.addEventListener('click', () => {
                    fetch(`http://localhost:3000/avaliable-clouds/${folder}/${cloud}`, { method: 'GET' }).then((response) => {
                        response.blob().then((res) => {
                            const pcdBlob = URL.createObjectURL(res);
                            addPCDFile(pcdBlob, cloud);
                        })
                    });
                });

                const div = document.createElement('div');
                div.classList.add('load-cloud-input-container');

                div.appendChild(input);
                div.append(label);

                avaliableCloudsContainer.appendChild(div);
            }
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
    }

    function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;

        if (needResize) {
            renderer.setSize(width, height, false);
        }

        return needResize;
    }

    function render() {
        if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;

            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
        }

        raycaster.setFromCamera(pointer, camera);

        if (pcdFile.cloud && runningRaycaster) {
            const intersections = raycaster.intersectObjects([pcdFile.cloud]);
            intersection = intersections.length > 0 ? intersections[0] : null;

            if (intersection !== null) {
                sphere.position.copy(intersection.point);
                sphere.scale.set(1, 1, 1);
            }

            sphere.scale.multiplyScalar(0.98);
            sphere.scale.clampScalar(5, 1);
        }

        controls.update();
        renderer.render(scene, camera);
    }

    function addEventListeners() {
        // raycaster selected point
        document.addEventListener('pointermove', onPointerMove);

        // find fiducial point
        findFiducialPointButton.addEventListener('click', () => findFiducialPoint());

        // select point button click
        selectPointButton.addEventListener('click', toggleRaycaster);

        // get point analysis
        analysisPointButton.addEventListener('click', getPointAnalysis)

        // download neighborhood cloud
        downloadButton.addEventListener('click', download);

        [...featuresCheckboxes].forEach(c => c.addEventListener('change', e => {
            e.currentTarget.timeval = new Date().getTime();
        }));

        inputFile.addEventListener('change', () => addPCDFile());

        clearSceneButton.addEventListener('click', cleanScene);

        document.getElementById('nosetip-point').addEventListener('click', e => {
            [...featuresCheckboxes].forEach(c => {
                c.disabled = true;
                c.classList.add('blocked');
            });
            featuresThresholdInput.classList.add('blocked');
            featuresThresholdInput.disabled = true;
            gfSearchRadius.classList.add('blocked');
            gfSearchRadius.disabled = true;
        });

        document.getElementById('left-right-eye-point').addEventListener('click', e => {
            [...featuresCheckboxes].forEach(c => {
                c.disabled = false;
                c.classList.remove('blocked');
            });
            featuresThresholdInput.classList.remove('blocked');
            featuresThresholdInput.disabled = false;
            gfSearchRadius.classList.remove('blocked');
            gfSearchRadius.disabled = false;
        });

        // select point on keydown
        document.addEventListener('keydown', e => {
            if (e.key === 's' || e.key === 'S') {
                toggleRaycaster();
            }
        }, false);
    }

    // Event Lisntener Functions

    function addPCDFile(blobURL = undefined, cloudName = undefined) {
        let inputUrl = '';
        let filename = '';

        if (blobURL) {
            inputUrl = blobURL;
            filename = cloudName;
        } else {
            inputUrl = URL.createObjectURL(inputFile.files[0]);
            filename = inputFile.files[0].name;
        }

        if (inputUrl) {
            loader.load(inputUrl, pointCloud => {
                if (clearSceneCheckbox.checked) {
                    cleanScene();
                }

                pointCloud.material.size = 0.8;
                scene.add(pointCloud);

                const inputCenter = pointCloud.geometry.boundingSphere.center;
                center.x = inputCenter.x;
                center.y = inputCenter.y;
                center.z = inputCenter.z;

                controls.target.set(center.x, center.y, center.z);
                camera.position.set(center.x, center.y, center.z + 200);
                controls.update();

                const guiColor = gui.addColor(new ColorGUIHelper(pointCloud.material, 'color'), 'value').name(`Color ${fileCounter}`);
                const guiSize = gui.add(new SizeGUIHelper(pointCloud.material, 'size'), 'value', 0, 150, 1).name(`Size ${fileCounter}`);

                fileCounter += 1;
                pcdFile = {
                    cloud: pointCloud,
                    blobURL: inputUrl,
                    filename,
                    guiColor,
                    guiSize,
                };
            });
        }
    }

    async function findFiducialPoint() {
        if (!pcdFile.cloud) {
            alert('Selecione uma nuvem primeiro!!');
            return;
        }

        const fiducialPoint = document.getElementById('nosetip-point').checked ? 'nosetip' : 'eye';

        const features = [...featuresCheckboxes]
            .filter(c => c.checked)
            .sort((a, b) => a.timeval - b.timeval)
            .map(f => f.value).join(',');

        if (fiducialPoint === 'eye' && !features) {
            alert('Selecione alguma feature!');
            return;
        }

        const featuresThreshold = featuresThresholdInput.value.replace(/(^,)|(,$)/g, '');

        if (features.split(',').filter(Boolean).length !== featuresThreshold.split(',').filter(Boolean).length) {
            alert('Número de features e thresholds devem ser iguais.');
            return;
        }

        cleanCloudLogEntries();
        cleanPointAnalysis();

        const inputUrl = pcdFile.blobURL;
        const sendBlob = await fetch(inputUrl).then(blob => blob.blob());
        const randomFilename = Math.random().toString(36).substring(7) + '.pcd'
        const sendFile = new File([sendBlob], randomFilename);

        const flexibilizeThresholds = document.getElementById('flexibilizeThresholds');
        const flexibilizeCrop = document.getElementById('flexibilizeCrop');
        const computationRadiusOrKSize = document.getElementById('computationRadiusOrKSize');
        const computationMethod = document.getElementById('radiusMethod').checked ? 'radius' : 'k';
        const minGaussianCurvature = document.getElementById('minGaussianCurvature');
        const shapeIndexLimit = document.getElementById('shapeIndexLimit');
        const minCropSize = document.getElementById('minCropSize');
        const maxCropSize = document.getElementById('maxCropSize');
        const minPointsToContinue = document.getElementById('minPointsToContinue');
        const removeIsolatedPointsRadius = document.getElementById('removeIsolatedPointsRadius');
        const removeIsolatedPointsThreshold = document.getElementById('removeIsolatedPointsThreshold');
        const nosetipSearchRadius = document.getElementById('nosetipSearchRadius');
        const gfSearchRadius = document.getElementById('gfSearchRadius');

        const formData = new FormData();

        formData.append('flexibilizeThresholds', flexibilizeThresholds.checked);
        formData.append('flexibilizeCrop', flexibilizeCrop.checked);
        formData.append('computationRadiusOrKSize', computationRadiusOrKSize.value);
        formData.append('computationMethod', computationMethod);
        formData.append('minGaussianCurvature', minGaussianCurvature.value);
        formData.append('shapeIndexLimit', shapeIndexLimit.value);
        formData.append('minCropSize', minCropSize.value);
        formData.append('maxCropSize', maxCropSize.value);
        formData.append('minPointsToContinue', minPointsToContinue.value);
        formData.append('removeIsolatedPointsRadius', removeIsolatedPointsRadius.value);
        formData.append('removeIsolatedPointsThreshold', removeIsolatedPointsThreshold.value);
        formData.append('nosetipSearchRadius', nosetipSearchRadius.value);
        formData.append('gfSearchRadius', gfSearchRadius.value);
        formData.append('features', features);
        formData.append('featuresThreshold', featuresThreshold);
        formData.append('fiducialPoint', fiducialPoint);
        formData.append('file', sendFile);

        const response = await fetch('http://localhost:3000/find-fiducial-point', {
            method: 'POST',
            body: formData
        });
        const data = await response.json();

        if (!response.ok) {
            alert('Algum erro ocorreu: ' + data.msg);

            return;
        }

        data.intermediary_clouds.forEach(cloudLog => addPointCloudFromCloudLog(cloudLog));

        const fiducialPointCloudLog = {
            cloud_label: 'Fiducial Point',
            cloud: [{ x: data.point.x, y: data.point.y, z: data.point.z }]
        };

        addPointCloudFromCloudLog(fiducialPointCloudLog, 150, 400, 1, 4, '#FFFFFF');
    }

    async function getPointAnalysis() {
        if (!selectedNosetipCloud || (Object.keys(selectedNosetipCloud).length === 0 && selectedNosetipCloud.constructor === Object)) {
            alert('Selecione um ponto antes de realizar sua análise');
            return;
        }

        const inputUrl = pcdFile.blobURL;
        const sendBlob = await fetch(inputUrl).then(blob => blob.blob());
        const randomFilename = Math.random().toString(36).substring(7) + '.pcd'
        const sendFile = new File([sendBlob], randomFilename);

        const method = document.getElementById('pointAnalysisRadiusMethod').checked ? 'radius' : 'k';
        const pointAnalysisComputationRadiusOrKSize = document.getElementById('pointAnalysisComputationRadiusOrKSize');

        const formData = new FormData();

        formData.append('file', sendFile);
        formData.append('computationMethod', method);
        formData.append('computationSize', pointAnalysisComputationRadiusOrKSize.value);
        formData.append('pointIndexToAnalyze', selectedNosetipCloud.index);

        const response = await fetch('http://localhost:3000/point-analysis', {
            method: 'POST',
            body: formData
        });
        const data = await response.json();

        if (!response.ok) {
            alert('Algum erro ocorreu: ' + data.msg);

            return;
        }

        insertPointAnalysisOnHTML(data.point_analysis);

        const cloudLog = {
            cloud_label: 'Neighborhood',
            cloud: data.point_analysis.neighborhood
        };

        addPointCloudFromCloudLog(cloudLog);
    }

    function onPointerMove(event) {
        pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
    }

    function toggleRaycaster() {
        if (runningRaycaster) {
            scene.remove(sphere);
            canvas.removeEventListener('click', runRaycast);
        } else {
            scene.add(sphere);
            canvas.addEventListener('click', runRaycast);
        }

        runningRaycaster = !runningRaycaster;
    }

    function runRaycast(e) {
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObject(pcdFile.cloud);

        if (intersects.length) {
            cleanSelectedNosetipCloud();
            cleanPointAnalysis();

            const newColor = new THREE.Color();
            newColor.setRGB(1, 1, 1);

            const index = intersects[0].index;

            toggleRaycaster();

            const material = new THREE.PointsMaterial({ size: 1.5, color: '#FFFFFF' });

            const point = {
                x: pcdFile.cloud.geometry.getAttribute('position').getX(index),
                y: pcdFile.cloud.geometry.getAttribute('position').getY(index),
                z: pcdFile.cloud.geometry.getAttribute('position').getZ(index)
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(
                [new THREE.Vector3(point.x, point.y, point.z)]
            );

            const newCloud = new THREE.Points(geometry, material);
            scene.add(newCloud);

            const guiColor = gui.addColor(new ColorGUIHelper(newCloud.material, 'color'), 'value').name(`Selected point ${fileCounter}`);
            const guiSize = gui.add(new SizeGUIHelper(newCloud.material, 'size'), 'value', 150, 400, 1).name(`Selected point ${fileCounter}`);

            selectedNosetipCloud = {
                cloud: newCloud,
                point,
                index,
                guiColor,
                guiSize
            }

            fileCounter += 1;
        }
    }

    function toggleFocusRaycaster(e) {
        if (runningFocusRaycaster) {
            canvas.removeEventListener('click', focusOnNewPoint);
        } else {
            canvas.addEventListener('click', focusOnNewPoint);
        }

        runningFocusRaycaster = !runningFocusRaycaster;
    }

    function insertPointAnalysisOnHTML(pointAnalysis) {
        document.getElementById('pointAnalysisResult').innerHTML = `
        <span><b>Point (x,y,z): </b>(${selectedNosetipCloud.point.x.toFixed(5)}, ${selectedNosetipCloud.point.y.toFixed(5)}, ${selectedNosetipCloud.point.z.toFixed(5)})</span><br/>
        <span><b>Número de pontos: </b>${pointAnalysis.neighborhood.length}</span><br/>
        <span><b>Gaussian Curvature: </b>${pointAnalysis.gaussian_curvature.toFixed(5)}</span><br/>
        <span><b>Shape Index: </b>${pointAnalysis.shape_index.toFixed(5)}</span><br/>
        <span><b>Normal (x,y,z): </b>(${pointAnalysis.normal.x.toFixed(5)}, ${pointAnalysis.normal.y.toFixed(5)}, ${pointAnalysis.normal.z.toFixed(5)})</span><br/>
        <span><b>PCs (k1,k2): </b>(${pointAnalysis.principal_curvatures.k1.toFixed(5)}, ${pointAnalysis.principal_curvatures.k2.toFixed(5)})</span><br/>
        <span><b>Soma: </b>${pointAnalysis.geometric_features.sum.toFixed(5)}</span><br/>
        <span><b>Omnivariância: </b>${pointAnalysis.geometric_features.omnivariance.toFixed(5)}</span><br/>
        <span><b>Autoentropia: </b>${pointAnalysis.geometric_features.eigenentropy.toFixed(5)}</span><br/>
        <span><b>Anisotropia: </b>${pointAnalysis.geometric_features.anisotropy.toFixed(5)}</span><br/>
        <span><b>Planaridade: </b>${pointAnalysis.geometric_features.planarity.toFixed(5)}</span><br/>
        <span><b>Linearidade: </b>${pointAnalysis.geometric_features.linearity.toFixed(5)}</span><br/>
        <span><b>Variação de superfície: </b>${pointAnalysis.geometric_features.surfaceVariation.toFixed(5)}</span><br/>
        <span><b>Esfericidade: </b>${pointAnalysis.geometric_features.sphericity.toFixed(5)}</span><br/>
        <span><b>Verticalidade: </b>${pointAnalysis.geometric_features.verticality.toFixed(5)}</span><br/>
        `;
    }

    function addPointCloudFromCloudLog(cloudLog, minSize = 0, maxSize = 150, step = 1, initialPointSize = 2, color = undefined) {
        let materialColor = color;

        if (!color) {
            materialColor = `#${Math.floor(Math.random()*16777215).toString(16)}`;
        }

        const material = new THREE.PointsMaterial({ size: initialPointSize, color: materialColor });
        const points = [];

        cloudLog.cloud.forEach(point => {
            points.push(new THREE.Vector3(point.x, point.y, point.z));
        });

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const newCloud = new THREE.Points(geometry, material);
        newCloud.userData.points = points;
        newCloud.name = 'neighborhood';
        scene.add(newCloud);

        if (!pcdFile || (Object.keys(pcdFile).length === 0 && pcdFile.constructor === Object)) {
            newCloud.geometry.computeBoundingSphere();
            const inputCenter = newCloud.geometry.boundingSphere.center;
            center.x = inputCenter.x;
            center.y = inputCenter.y;
            center.z = inputCenter.z;

            controls.target.set( center.x, center.y, center.z );
            controls.update();
        }

        const guiColor = gui.addColor(new ColorGUIHelper(newCloud.material, 'color'), 'value').name(cloudLog.cloud_label);
        const guiSize = gui.add(new SizeGUIHelper(newCloud.material, 'size'), 'value', minSize, maxSize, step).name(cloudLog.cloud_label);

        cloudLogFiles.push({
            cloud: newCloud,
            guiColor,
            guiSize,
        })

        fileCounter += 1;
    }

    function download() {
        if (!selectedNosetipCloud.point) {
            return;
        }

        const saveData = (function () {
            const a = document.createElement('a');
            document.body.appendChild(a);
            a.style = 'display: none';
            return (data, fileName) => {
                const blob = new Blob([data], { type: 'octet/stream' });
                const url = window.URL.createObjectURL(blob);
                a.href = url;
                a.download = fileName;
                a.click();
                window.URL.revokeObjectURL(url);
            };
        }());

        const cloud = scene.getObjectByName('neighborhood', true);

        let baseFile = '# .PCD v0.7 - Point Cloud Data file format\nVERSION 0.7\nFIELDS x y z\nSIZE 4 4 4\nTYPE F F F\nCOUNT 1 1 1\nWIDTH 1\nHEIGHT 1\nVIEWPOINT 0 0 0 1 0 0 0\nPOINTS 1\nDATA ascii\n';
        baseFile = baseFile + `${selectedNosetipCloud.point.x} ${selectedNosetipCloud.point.y} ${selectedNosetipCloud.point.z}\n`;

        const points = cloud.userData.points;
        for (let i = 0; i < points.length; i++) {
            baseFile += `${points[i].x} ${points[i].y} ${points[i].z}\n`
        }

        saveData(baseFile, `point_selected_${pcdFile.filename}`);
    }

    function cleanPointAnalysis() {
        document.getElementById('pointAnalysisResult').innerHTML = '';
    }

    function cleanSelectedNosetipCloud() {
        if ('cloud' in selectedNosetipCloud && selectedNosetipCloud.cloud) {
            scene.remove(selectedNosetipCloud.cloud);
            delete selectedNosetipCloud.cloud;
        }

        if ('guiColor' in selectedNosetipCloud && selectedNosetipCloud.guiColor) {
            gui.remove(selectedNosetipCloud.guiColor);
            delete selectedNosetipCloud.guiColor;
        }

        if ('guiSize' in selectedNosetipCloud && selectedNosetipCloud.guiSize) {
            gui.remove(selectedNosetipCloud.guiSize);
            delete selectedNosetipCloud.guiSize;
        }

        selectedNosetipCloud = {};
        cleanPointAnalysis();
    }

    function cleanCloudLogEntries() {
        for (let i = 0; i < cloudLogFiles.length; i++) {
            const c = cloudLogFiles[i];

            scene.remove(c.cloud);
            gui.remove(c.guiColor);
            gui.remove(c.guiSize);
        }

        cloudLogFiles = [];
    }

    function cleanPCDFile() {
        if ('cloud' in pcdFile && pcdFile.cloud) {
            scene.remove(pcdFile.cloud);
        }

        if ('guiColor' in pcdFile && pcdFile.guiColor) {
            gui.remove(pcdFile.guiColor);
        }

        if ('guiSize' in pcdFile && pcdFile.guiSize) {
            gui.remove(pcdFile.guiSize);
        }

        pcdFile = {};
    }

    function cleanScene() {
        cleanPCDFile();
        cleanSelectedNosetipCloud();
        cleanCloudLogEntries();
    }

    function focusOnNewPoint(e) {
        mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;

        focusRaycaster.setFromCamera(mouse, camera);

        const intersects = focusRaycaster.intersectObject(pcdFile.cloud);

        if (intersects.length) {
            const index = intersects[0].index;

            const point = {
                x: pcdFile.cloud.geometry.getAttribute('position').getX(index),
                y: pcdFile.cloud.geometry.getAttribute('position').getY(index),
                z: pcdFile.cloud.geometry.getAttribute('position').getZ(index)
            }

            controls.target.set( point.x, point.y, point.z );
            camera.position.set( point.x, point.y, point.z + 50 );
            controls.update();

            toggleFocusRaycaster();
        }
    }

    init();
    animate();
</script>
</html>
