<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LATIN PCD Viewer</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="sidemenu">
        <div class="load-image p1-all">
            <label for="pcdInputFile">Carregue uma nuvem:</label>
            <input type="file" id="pcdInputFile" name="pcdInputFile" accept=".pcd">
            <br/>
            <br/>

            <input id="clearSceneCheckbox" type="checkbox" checked>
            <label for="clearSceneCheckbox">Limpar tela</label>
        </div>

        <div class="separator"></div>

        <div class="avaliable-folders-container p1-all" id="avaliableFoldersContainer"></div>
        <div class="avaliable-clouds-container" id="avaliableCloudsContainer"></div>

        <div class="separator"></div>

        <div class="point-analysis p1-all">
            <h4>Análise de ponto</h4>

            <label for="pointAnalysisRadiusMethod">Método de computação:</label>
            <input type="radio" id="pointAnalysisRadiusMethod" name="pointAnalysisMethod" value="radius" checked>
            <label for="pointAnalysisRadiusMethod">Raio</label>
            <input type="radio" id="pointAnalysisKMethod" name="pointAnalysisMethod" value="k">
            <label for="pointAnalysisKMethod">K Vizinhos</label>
            <br/>

            <label for="pointAnalysisComputationRadiusOrKSize">Valor usado para computar Normal e PC:</label>
            <input type="number" id="pointAnalysisComputationRadiusOrKSize" name="pointAnalysisComputationRadiusOrKSize" value="13" style="width: 80px">
            <br/>

            <input id="selectPointButton" style="margin-top: 10px;" type="submit" value="Selecionar ponto">
            <input id="analysisPointButton" style="margin-top: 10px;" type="submit" value="Analisar">
            <input id="downloadButton" style="margin-top: 10px;" type="submit" value="Download">
            <div id="pointAnalysisResult"></div>
        </div>

        <div class="separator"></div>


        <div class="pipeline-container p1-all">
            <h4>Filtros</h2>

            <div class="filters-container">
                <div class="input-container">
                    <input id="filters-input" class="filters" list="filters" placeholder="Escolha um filtro..." />
                    <datalist id="filters">
                        <option value="Shape Index">
                        <option value="Curvatura Gaussiana">
                        <option value="Soma">
                        <option value="Omnivariância">
                        <option value="Autoentropia">
                        <option value="Anisotropia">
                        <option value="Planaridade">
                        <option value="Linearidade">
                        <option value="Esfericidade">
                        <option value="Variação de Superfície">
                        <option value="Verticalidade">
                    </datalist>
                </div>
                <button id="add-filter" class="add-filter">Adicionar filtro</button>
            </div>

            <div class="pipeline-filter" draggable="true">
                <div class="collapsible" data-feature="Shape Index">
                    <span>Shape Index</span>
                    <button class="remove-filter">X</button>
                </div>
                <!-- Shape Index -->
                <div class="content">
                    <label for="shapeIndexKDTreeMethodRadius">Método de computação:</label>
                    <input type="radio" id="shapeIndexKDTreeMethodRadius" name="shapeIndexKDTreeMethod" value="radius" checked>
                    <label for="shapeIndexKDTreeMethodRadius">Raio</label>
                    <input type="radio" id="shapeIndexKDTreeMethodK" name="shapeIndexKDTreeMethod" value="k">
                    <label for="shapeIndexKDTreeMethodK">K Vizinhos</label>
                    <br/>
                    <label for="shapeIndexKDTreeValue">Valor usado para computar Normal e PC:</label>
                    <input type="number" id="shapeIndexKDTreeValue" name="shapeIndexKDTreeValue" value="13" style="width: 40px">
                    <br/>
                    <label for="shapeIndexMinThreshold">Threshold mínimo:</label>
                    <input type="number" id="shapeIndexMinThreshold" name="shapeIndexMinThreshold" value="13" style="width: 80px">
                    <br/>
                    <label for="shapeIndexMaxThreshold">Threshold máximo:</label>
                    <input type="number" id="shapeIndexMaxThreshold" name="shapeIndexMaxThreshold" value="13" style="width: 80px">
                    <br/>
                </div>
            </div>

            <div class="pipeline-filter" draggable="true">
                <div class="collapsible" data-feature="Curvatura Gaussiana">
                    <span>Curvatura Gaussiana</span>
                    <button class="remove-filter">X</button>
                </div>
                <!-- Curvatura Gaussiana -->
                <div class="content">
                    <label for="gaussianCurvatureKDTreeMethodRadius">Método de computação:</label>
                    <input type="radio" id="gaussianCurvatureKDTreeMethodRadius" name="gaussianCurvatureKDTreeMethod" value="radius" checked>
                    <label for="gaussianCurvatureKDTreeMethodRadius">Raio</label>
                    <input type="radio" id="gaussianCurvatureKDTreeMethodK" name="gaussianCurvatureKDTreeMethod" value="k">
                    <label for="gaussianCurvatureKDTreeMethodK">K Vizinhos</label>
                    <br/>
                    <label for="gaussianCurvatureKDTreeValue">Valor usado para computar Normal e PC:</label>
                    <input type="number" id="gaussianCurvatureKDTreeValue" name="gaussianCurvatureKDTreeValue" value="13" style="width: 40px">
                    <br/>
                    <label for="gaussianCurvatureMinThreshold">Threshold mínimo:</label>
                    <input type="number" id="gaussianCurvatureMinThreshold" name="gaussianCurvatureMinThreshold" value="13" style="width: 80px">
                    <br/>
                    <label for="gaussianCurvatureMaxThreshold">Threshold máximo:</label>
                    <input type="number" id="gaussianCurvatureMaxThreshold" name="gaussianCurvatureMaxThreshold" value="13" style="width: 80px">
                    <br/>
                </div>
            </div>

            <div class="pipeline-filter" draggable="true">
                <div class="collapsible" data-feature="Soma">
                    <span>Soma</span>
                    <button class="remove-filter">X</button>
                </div>
                <!-- Soma -->
                <div class="content">
                    <label for="gfSumKDTreeMethodRadius">Método de computação:</label>
                    <input type="radio" id="gfSumKDTreeMethodRadius" name="gfSumKDTreeMethod" value="radius" checked>
                    <label for="gfSumKDTreeMethodRadius">Raio</label>
                    <input type="radio" id="gfSumKDTreeMethodK" name="gfSumKDTreeMethod" value="k">
                    <label for="gfSumKDTreeMethodK">K Vizinhos</label>
                    <br/>
                    <label for="gfSumKDTreeValue">Valor usado para calcular a vizinhança:</label>
                    <input type="number" id="gfSumKDTreeValue" name="gfSumKDTreeValue" value="13" style="width: 40px">
                    <br/>
                    <label for="gfSumMinThreshold">Threshold mínimo:</label>
                    <input type="number" id="gfSumMinThreshold" name="gfSumMinThreshold" value="13" style="width: 80px">
                    <br/>
                    <label for="gfSumMaxThreshold">Threshold máximo:</label>
                    <input type="number" id="gfSumMaxThreshold" name="gfSumMaxThreshold" value="13" style="width: 80px">
                    <br/>
                </div>
            </div>

            <div class="pipeline-filter" draggable="true">
                <div class="collapsible" data-feature="Omnivariância">
                    <span>Omnivariância</span>
                    <button class="remove-filter">X</button>
                </div>
                <!-- Omnivariância -->
                <div class="content">
                    <label for="gfOmnivarianceKDTreeMethodRadius">Método de computação:</label>
                    <input type="radio" id="gfOmnivarianceKDTreeMethodRadius" name="gfOmnivarianceKDTreeMethod" value="radius" checked>
                    <label for="gfOmnivarianceKDTreeMethodRadius">Raio</label>
                    <input type="radio" id="gfOmnivarianceKDTreeMethodK" name="gfOmnivarianceKDTreeMethod" value="k">
                    <label for="gfOmnivarianceKDTreeMethodK">K Vizinhos</label>
                    <br/>
                    <label for="gfOmnivarianceKDTreeValue">Valor usado para calcular a vizinhança:</label>
                    <input type="number" id="gfOmnivarianceKDTreeValue" name="gfOmnivarianceKDTreeValue" value="13" style="width: 40px">
                    <br/>
                    <label for="gfOmnivarianceMinThreshold">Threshold mínimo:</label>
                    <input type="number" id="gfOmnivarianceMinThreshold" name="gfOmnivarianceMinThreshold" value="13" style="width: 80px">
                    <br/>
                    <label for="gfOmnivarianceMaxThreshold">Threshold máximo:</label>
                    <input type="number" id="gfOmnivarianceMaxThreshold" name="gfOmnivarianceMaxThreshold" value="13" style="width: 80px">
                    <br/>
                </div>
            </div>

            <div class="pipeline-filter" draggable="true">
                <div class="collapsible" data-feature="Autoentropia">
                    <span>Autoentropia</span>
                    <button class="remove-filter">X</button>
                </div>
                <!-- Autoentropia -->
                <div class="content">
                    <label for="gfEigenentropyKDTreeMethodRadius">Método de computação:</label>
                    <input type="radio" id="gfEigenentropyKDTreeMethodRadius" name="gfEigenentropyKDTreeMethod" value="radius" checked>
                    <label for="gfEigenentropyKDTreeMethodRadius">Raio</label>
                    <input type="radio" id="gfEigenentropyKDTreeMethodK" name="gfEigenentropyKDTreeMethod" value="k">
                    <label for="gfEigenentropyKDTreeMethodK">K Vizinhos</label>
                    <br/>
                    <label for="gfEigenentropyKDTreeValue">Valor usado para calcular a vizinhança:</label>
                    <input type="number" id="gfEigenentropyKDTreeValue" name="gfEigenentropyKDTreeValue" value="13" style="width: 40px">
                    <br/>
                    <label for="gfEigenentropyMinThreshold">Threshold mínimo:</label>
                    <input type="number" id="gfEigenentropyMinThreshold" name="gfEigenentropyMinThreshold" value="13" style="width: 80px">
                    <br/>
                    <label for="gfEigenentropyMaxThreshold">Threshold máximo:</label>
                    <input type="number" id="gfEigenentropyMaxThreshold" name="gfEigenentropyMaxThreshold" value="13" style="width: 80px">
                    <br/>
                </div>
            </div>

            <div class="pipeline-filter" draggable="true">
                <div class="collapsible" data-feature="Anisotropia">
                    <span>Anisotropia</span>
                    <button class="remove-filter">X</button>
                </div>
                <!-- Anisotropia -->
                <div class="content">
                    <label for="gfAnisotropyKDTreeMethodRadius">Método de computação:</label>
                    <input type="radio" id="gfAnisotropyKDTreeMethodRadius" name="gfAnisotropyKDTreeMethod" value="radius" checked>
                    <label for="gfAnisotropyKDTreeMethodRadius">Raio</label>
                    <input type="radio" id="gfAnisotropyKDTreeMethodK" name="gfAnisotropyKDTreeMethod" value="k">
                    <label for="gfAnisotropyKDTreeMethodK">K Vizinhos</label>
                    <br/>
                    <label for="gfAnisotropyKDTreeValue">Valor usado para calcular a vizinhança:</label>
                    <input type="number" id="gfAnisotropyKDTreeValue" name="gfAnisotropyKDTreeValue" value="13" style="width: 40px">
                    <br/>
                    <label for="gfAnisotropyMinThreshold">Threshold mínimo:</label>
                    <input type="number" id="gfAnisotropyMinThreshold" name="gfAnisotropyMinThreshold" value="13" style="width: 80px">
                    <br/>
                    <label for="gfAnisotropyMaxThreshold">Threshold máximo:</label>
                    <input type="number" id="gfAnisotropyMaxThreshold" name="gfAnisotropyMaxThreshold" value="13" style="width: 80px">
                    <br/>
                </div>
            </div>

            <div class="pipeline-filter" draggable="true">
                <div class="collapsible" data-feature="Planaridade">
                    <span>Planaridade</span>
                    <button class="remove-filter">X</button>
                </div>
                <!-- Planaridade -->
                <div class="content">
                    <label for="gfPlanarityKDTreeMethodRadius">Método de computação:</label>
                    <input type="radio" id="gfPlanarityKDTreeMethodRadius" name="gfPlanarityKDTreeMethod" value="radius" checked>
                    <label for="gfPlanarityKDTreeMethodRadius">Raio</label>
                    <input type="radio" id="gfPlanarityKDTreeMethodK" name="gfPlanarityKDTreeMethod" value="k">
                    <label for="gfPlanarityKDTreeMethodK">K Vizinhos</label>
                    <br/>
                    <label for="gfPlanarityKDTreeValue">Valor usado para calcular a vizinhança:</label>
                    <input type="number" id="gfPlanarityKDTreeValue" name="gfPlanarityKDTreeValue" value="13" style="width: 40px">
                    <br/>
                    <label for="gfPlanarityMinThreshold">Threshold mínimo:</label>
                    <input type="number" id="gfPlanarityMinThreshold" name="gfPlanarityMinThreshold" value="13" style="width: 80px">
                    <br/>
                    <label for="gfPlanarityMaxThreshold">Threshold máximo:</label>
                    <input type="number" id="gfPlanarityMaxThreshold" name="gfPlanarityMaxThreshold" value="13" style="width: 80px">
                    <br/>
                </div>
            </div>

            <div class="pipeline-filter" draggable="true">
                <div class="collapsible" data-feature="Linearidade">
                    <span>Linearidade</span>
                    <button class="remove-filter">X</button>
                </div>
                <!-- Linearidade -->
                <div class="content">
                    <label for="gfLinearityKDTreeMethodRadius">Método de computação:</label>
                    <input type="radio" id="gfLinearityKDTreeMethodRadius" name="gfLinearityKDTreeMethod" value="radius" checked>
                    <label for="gfLinearityKDTreeMethodRadius">Raio</label>
                    <input type="radio" id="gfLinearityKDTreeMethodK" name="gfLinearityKDTreeMethod" value="k">
                    <label for="gfLinearityKDTreeMethodK">K Vizinhos</label>
                    <br/>
                    <label for="gfLinearityKDTreeValue">Valor usado para calcular a vizinhança:</label>
                    <input type="number" id="gfLinearityKDTreeValue" name="gfLinearityKDTreeValue" value="13" style="width: 40px">
                    <br/>
                    <label for="gfLinearityMinThreshold">Threshold mínimo:</label>
                    <input type="number" id="gfLinearityMinThreshold" name="gfLinearityMinThreshold" value="13" style="width: 80px">
                    <br/>
                    <label for="gfLinearityMaxThreshold">Threshold máximo:</label>
                    <input type="number" id="gfLinearityMaxThreshold" name="gfLinearityMaxThreshold" value="13" style="width: 80px">
                    <br/>
                </div>
            </div>

            <div class="pipeline-filter" draggable="true">
                <div class="collapsible" data-feature="Esfericidade">
                    <span>Esfericidade</span>
                    <button class="remove-filter">X</button>
                </div>
                <!-- Esfericidade -->
                <div class="content">
                    <label for="gfSphericityKDTreeMethodRadius">Método de computação:</label>
                    <input type="radio" id="gfSphericityKDTreeMethodRadius" name="gfSphericityKDTreeMethod" value="radius" checked>
                    <label for="gfSphericityKDTreeMethodRadius">Raio</label>
                    <input type="radio" id="gfSphericityKDTreeMethodK" name="gfSphericityKDTreeMethod" value="k">
                    <label for="gfSphericityKDTreeMethodK">K Vizinhos</label>
                    <br/>
                    <label for="gfSphericityKDTreeValue">Valor usado para calcular a vizinhança:</label>
                    <input type="number" id="gfSphericityKDTreeValue" name="gfSphericityKDTreeValue" value="13" style="width: 40px">
                    <br/>
                    <label for="gfSphericityMinThreshold">Threshold mínimo:</label>
                    <input type="number" id="gfSphericityMinThreshold" name="gfSphericityMinThreshold" value="13" style="width: 80px">
                    <br/>
                    <label for="gfSphericityMaxThreshold">Threshold máximo:</label>
                    <input type="number" id="gfSphericityMaxThreshold" name="gfSphericityMaxThreshold" value="13" style="width: 80px">
                    <br/>
                </div>
            </div>

            <div class="pipeline-filter" draggable="true">
                <div class="collapsible" data-feature="Variação de Superfície">
                    <span>Variação de Superfície</span>
                    <button class="remove-filter">X</button>
                </div>
                <!-- Variação de Superfície -->
                <div class="content">
                    <label for="gfSurfaceVariationKDTreeMethodRadius">Método de computação:</label>
                    <input type="radio" id="gfSurfaceVariationKDTreeMethodRadius" name="gfSurfaceVariationKDTreeMethod" value="radius" checked>
                    <label for="gfSurfaceVariationKDTreeMethodRadius">Raio</label>
                    <input type="radio" id="gfSurfaceVariationKDTreeMethodK" name="gfSurfaceVariationKDTreeMethod" value="k">
                    <label for="gfSurfaceVariationKDTreeMethodK">K Vizinhos</label>
                    <br/>
                    <label for="gfSurfaceVariationKDTreeValue">Valor usado para calcular a vizinhança:</label>
                    <input type="number" id="gfSurfaceVariationKDTreeValue" name="gfSurfaceVariationKDTreeValue" value="13" style="width: 40px">
                    <br/>
                    <label for="gfSurfaceVariationMinThreshold">Threshold mínimo:</label>
                    <input type="number" id="gfSurfaceVariationMinThreshold" name="gfSurfaceVariationMinThreshold" value="13" style="width: 80px">
                    <br/>
                    <label for="gfSurfaceVariationMaxThreshold">Threshold máximo:</label>
                    <input type="number" id="gfSurfaceVariationMaxThreshold" name="gfSurfaceVariationMaxThreshold" value="13" style="width: 80px">
                    <br/>
                </div>
            </div>

            <div class="pipeline-filter" draggable="true">
                <div class="collapsible" data-feature="Verticalidade">
                    <span>Verticalidade</span>
                    <button class="remove-filter">X</button>
                </div>
                <!-- Verticalidade -->
                <div class="content">
                    <label for="gfVerticalityKDTreeMethodRadius">Método de computação:</label>
                    <input type="radio" id="gfVerticalityKDTreeMethodRadius" name="gfVerticalityKDTreeMethod" value="radius" checked>
                    <label for="gfVerticalityKDTreeMethodRadius">Raio</label>
                    <input type="radio" id="gfVerticalityKDTreeMethodK" name="gfVerticalityKDTreeMethod" value="k">
                    <label for="gfVerticalityKDTreeMethodK">K Vizinhos</label>
                    <br/>
                    <label for="gfVerticalityKDTreeValue">Valor usado para calcular a vizinhança:</label>
                    <input type="number" id="gfVerticalityKDTreeValue" name="gfVerticalityKDTreeValue" value="13" style="width: 40px">
                    <br/>
                    <label for="gfVerticalityMinThreshold">Threshold mínimo:</label>
                    <input type="number" id="gfVerticalityMinThreshold" name="gfVerticalityMinThreshold" value="13" style="width: 80px">
                    <br/>
                    <label for="gfVerticalityMaxThreshold">Threshold máximo:</label>
                    <input type="number" id="gfVerticalityMaxThreshold" name="gfVerticalityMaxThreshold" value="13" style="width: 80px">
                    <br/>
                </div>
            </div>
        </div>

        <div class="finducial-points p1-all">
            <h4>Encontrar ponto fiducial</h4>

            <input type="radio" id="nosetip-point" name="fiducial-point" checked>
            <label for="nosetip-point">Ponta do nariz</label>
            <br/>

            <input type="radio" id="left-right-eye-point" name="fiducial-point">
            <label for="left-right-eye-point">Olho esquerdo/direito (IN PROGRESS)</label>
            <br/>
            <br/>

            <input type="checkbox" id="flexibilizeThresholds" name="flexibilizeThresholds" checked>
            <label for="flexibilizeThresholds">Flexibilizar Thresholds:</label>
            <br/>

            <input type="checkbox" id="flexibilizeCrop" name="flexibilizeCrop" checked>
            <label for="flexibilizeCrop">Flexibilizar Crop:</label>
            <br/>
            <br/>

            <label for="radiusMethod">Método de computação:</label>
            <input type="radio" id="radiusMethod" name="computationMethod" value="radius" checked>
            <label for="radiusMethod">Raio</label>
            <input type="radio" id="kMethod" name="computationMethod" value="k">
            <label for="kMethod">K Vizinhos</label>
            <br/>

            <label for="computationRadiusOrKSize">Valor usado para computar Normal e PC:</label>
            <input type="number" id="computationRadiusOrKSize" name="computationRadiusOrKSize" value="13" style="width: 80px">
            <br/>

            <label for="minGaussianCurvature">GC mínima</label>
            <input type="number" id="minGaussianCurvature" name="minGaussianCurvature" value="0.0038" step="0.001">
            <br/>

            <label for="shapeIndexLimit">Limite de SI:</label>
            <input type="number" id="shapeIndexLimit" name="shapeIndexLimit" value="-0.78" step="0.01" style="width: 80px">
            <br/>

            <label for="minCropSize">Tamanho de Crop mínimo:</label>
            <input type="number" id="minCropSize" name="minCropSize" value="100" style="width: 80px">
            <br/>

            <label for="maxCropSize">Tamanho de Crop máximo:</label>
            <input type="number" id="maxCropSize" name="maxCropSize" value="240" style="width: 80px">
            <br/>

            <label for="minPointsToContinue">Quantidade mínima de pontos após filtros:</label>
            <input type="number" id="minPointsToContinue" name="minPointsToContinue" value="15" style="width: 80px">
            <br/>

            <label for="removeIsolatedPointsRadius">Raio de busca de pontos isolados:</label>
            <input type="number" id="removeIsolatedPointsRadius" name="removeIsolatedPointsRadius" value="5" style="width: 80px">
            <br/>

            <label for="removeIsolatedPointsThreshold">Threshold para pontos isolados:</label>
            <input type="number" id="removeIsolatedPointsThreshold" name="removeIsolatedPointsThreshold" value="6" style="width: 80px">
            <br/>

            <label for="nosetipSearchRadius">Raio para seleção da ponta do nariz:</label>
            <input type="number" id="nosetipSearchRadius" name="nosetipSearchRadius" value="12" style="width: 80px">
            <br/>

            <label for="sum">Features:</label>
            <br/>

            <input type="checkbox" data-feature name="sum" id="sum" value="Somatório">
            <label for="sum">Somatório</label>
            <br/>

            <input type="checkbox" data-feature name="eigenentropy" id="eigenentropy" value="Autoentropia">
            <label for="eigenentropy">Autoentropia</label>
            <br/>

            <input type="checkbox" data-feature name="anisotropy" id="anisotropy" value="Anisotropia">
            <label for="anisotropy">Anisotropia</label>
            <br/>

            <input type="checkbox" data-feature name="planarity" id="planarity" value="Planaridade">
            <label for="planarity">Planaridade</label>
            <br/>

            <input type="checkbox" data-feature name="linearity" id="linearity" value="Linearidade">
            <label for="linearity">Linearidade</label>
            <br/>

            <input type="checkbox" data-feature name="surface-variation" id="surface-variation" value="Variação de superfı́cie">
            <label for="surface-variation">Variação de superfı́cie</label>
            <br/>

            <input type="checkbox" data-feature name="sphericity" id="sphericity" value="Esfericidade">
            <label for="sphericity">Esfericidade</label>
            <br/>

            <input type="checkbox" data-feature name="verticality" id="verticality" value="Verticalidade">
            <label for="verticality">Verticalidade</label>
            <br/>

            <label for="gfSearchRadius">Raio para filtragem das features da MC:</label>
            <input type="number" id="gfSearchRadius" name="gfSearchRadius" value="10" min="0" step="5" style="width: 80px">
            <br/>

            <label for="featuresThreshold">Threshold para as features da MC:</label>
            <br/>
            <input type="text" id="featuresThreshold" name="featuresThreshold" style="width: 300px" placeholder="valores separados por vírgulas">
            <br>
            <small>*MC (Matriz de covariância)</small>
            <br/>
            <br/>

            <input id="findFiducialPointButton" type="submit" value="Encontrar ponto fiducial">
            <input id="clearScene" type="submit" value="Limpar tela">
            <br/>
        </div>
    </div>

    <canvas id="canvas"></canvas>
</body>
<script type="module">
    import * as THREE from './js/pcd-viewer/node_modules/three/build/three.module.js';
    import { PCDLoader } from './js/pcd-viewer/node_modules/three/examples/jsm/loaders/PCDLoader.js';
    import { TrackballControls} from './js/pcd-viewer/node_modules/three/examples/jsm/controls/TrackballControls.js';
    import { GUI } from './js/pcd-viewer/node_modules/three/examples/jsm/libs/dat.gui.module.js';
    import { ColorGUIHelper, SizeGUIHelper } from './js/pcd-viewer/helpers/index.js';

    let fileCounter = 1;
    const center = new THREE.Vector3(0, 0, 0);

    // buttons
    const findFiducialPointButton = document.getElementById('findFiducialPointButton');
    const selectPointButton = document.getElementById('selectPointButton');
    const analysisPointButton = document.getElementById('analysisPointButton');
    const downloadButton = document.getElementById('downloadButton');
    const clearSceneButton = document.getElementById('clearScene');

    // pipeline settings
    const collapsibles = document.querySelectorAll('.collapsible');
    const removeFilters = document.querySelectorAll('.remove-filter');
    const filtersInput = document.getElementById('filters-input');
    const addFilterButton = document.getElementById('add-filter');
    const pipelineContainer = document.querySelector('.pipeline-container')
    const avaliableFilters = [
        'Shape Index', 'Curvatura Gaussiana', 'Soma', 'Omnivariância', 'Autoentropia', 'Anisotropia',
        'Planaridade', 'Linearidade', 'Esfericidade', 'Variação de Superfície', 'Verticalidade'
    ];
    const currentFilters = [...avaliableFilters];
    const items = document.querySelectorAll('.pipeline-filter');
    let dragSrcEl = null;

    // checkboxes
    const clearSceneCheckbox = document.getElementById('clearSceneCheckbox');
    const featuresCheckboxes = document.querySelectorAll('input[type="checkbox"][data-feature]');

    // inputs
    const featuresThresholdInput = document.getElementById('featuresThreshold');

    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas });
    const fov = 50; const aspect = 2; const near = 0.1; const far = 10000;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    const mouse = new THREE.Vector2();
    const controls = new TrackballControls(camera, renderer.domElement);
    const scene = new THREE.Scene();

    let intersection = null;
    const pointer = new THREE.Vector2();
    const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

    const inputFile = document.getElementById('pcdInputFile');
    const gui = new GUI();
    const loader = new PCDLoader();

    const raycaster = new THREE.Raycaster();
    const focusRaycaster = new THREE.Raycaster();

    let pcdFile = {};
    let cloudLogFiles = [];
    let runningRaycaster = false;
    let runningFocusRaycaster = false;
    let selectedNosetipCloud = {};
    let pointAnalysis = {};

    function init() {
        loadAvaliableClouds();
        addEventListeners();

        // controls settings
        controls.rotateSpeed = 5.0;
        controls.zoomSpeed = 2;
        controls.panSpeed = 0.5;
        controls.staticMoving = true;

        scene.background = new THREE.Color(0x000000);
        scene.add(new THREE.AmbientLight(0xFFFFFF, 1));
        scene.add(sphere);

        raycaster.params.Points.threshold = 0.5;
        focusRaycaster.params.Points.threshold = 10;

        // disable by default features selection
        document.getElementById('nosetip-point').click();

        function loadAvaliableClouds() {
            fetch('http://localhost:3000/avaliable-clouds', { method: 'GET' }).then((response) => {
                response.json().then(res => {
                    setAvaliableFoldersHTML(res);
                })
            });
        }

        function setAvaliableFoldersHTML(folders) {
            const avaliableFoldersContainer = document.getElementById('avaliableFoldersContainer');

            for (let folder in folders) {
                const folderContainer = document.createElement('div');

                folderContainer.classList.add('avaliable-folder');
                folderContainer.id = 'folder-' + folder;
                folderContainer.innerText = folder;

                folderContainer.addEventListener('click', () => {
                    setAvaliableCloudsHTML(folder, folders[folder]);
                });

                avaliableFoldersContainer.appendChild(folderContainer);
            }

            document.getElementById(`folder-${Object.keys(folders)[0]}`).click();
        }

        function setAvaliableCloudsHTML(folder, clouds) {
            const avaliableCloudsContainer = document.getElementById('avaliableCloudsContainer');
            avaliableCloudsContainer.innerHTML = '';

            for (let cloud of clouds) {
                const input = document.createElement('input');
                input.type = 'submit';
                input.id = 'load-input-' + cloud;
                input.value = 'Carregar';

                const label = document.createElement('label');
                label.for = 'load-input-' + cloud;
                label.id = 'label-' + cloud;
                label.innerText = cloud;

                input.addEventListener('click', () => {
                    fetch(`http://localhost:3000/avaliable-clouds/${folder}/${cloud}`, { method: 'GET' }).then((response) => {
                        response.blob().then((res) => {
                            const pcdBlob = URL.createObjectURL(res);
                            addPCDFile(pcdBlob, cloud);
                        })
                    });
                });

                const div = document.createElement('div');
                div.classList.add('load-cloud-input-container');

                div.appendChild(input);
                div.append(label);

                avaliableCloudsContainer.appendChild(div);
            }
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
    }

    function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;

        if (needResize) {
            renderer.setSize(width, height, false);
        }

        return needResize;
    }

    function render() {
        if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;

            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
        }

        raycaster.setFromCamera(pointer, camera);

        if (pcdFile.cloud && runningRaycaster) {
            const intersections = raycaster.intersectObjects([pcdFile.cloud]);
            intersection = intersections.length > 0 ? intersections[0] : null;

            if (intersection !== null) {
                sphere.position.copy(intersection.point);
                sphere.scale.set(1, 1, 1);
            }

            sphere.scale.multiplyScalar(0.98);
            sphere.scale.clampScalar(5, 1);
        }

        controls.update();
        renderer.render(scene, camera);
    }

    function addEventListeners() {
        // raycaster selected point
        document.addEventListener('pointermove', onPointerMove);

        // find fiducial point
        findFiducialPointButton.addEventListener('click', () => findFiducialPoint());

        // select point button click
        selectPointButton.addEventListener('click', toggleRaycaster);

        // get point analysis
        analysisPointButton.addEventListener('click', getPointAnalysis)

        // download neighborhood cloud
        downloadButton.addEventListener('click', download);

        [...featuresCheckboxes].forEach(c => c.addEventListener('change', e => {
            e.currentTarget.timeval = new Date().getTime();
        }));

        inputFile.addEventListener('change', () => addPCDFile());

        clearSceneButton.addEventListener('click', cleanScene);

        document.getElementById('nosetip-point').addEventListener('click', e => {
            [...featuresCheckboxes].forEach(c => {
                c.disabled = true;
                c.classList.add('blocked');
            });
            featuresThresholdInput.classList.add('blocked');
            featuresThresholdInput.disabled = true;
            gfSearchRadius.classList.add('blocked');
            gfSearchRadius.disabled = true;
        });

        document.getElementById('left-right-eye-point').addEventListener('click', e => {
            [...featuresCheckboxes].forEach(c => {
                c.disabled = false;
                c.classList.remove('blocked');
            });
            featuresThresholdInput.classList.remove('blocked');
            featuresThresholdInput.disabled = false;
            gfSearchRadius.classList.remove('blocked');
            gfSearchRadius.disabled = false;
        });

        // select point on keydown
        document.addEventListener('keydown', e => {
            if (e.key === 's' || e.key === 'S') {
                toggleRaycaster();
            }
        }, false);

        [...collapsibles].forEach(coll => coll.addEventListener('click', collapse));

        [...removeFilters].forEach(filter => filter.addEventListener('click', removeFilter));

        addFilterButton.addEventListener('click', () => {
            const filterName = filtersInput.value;

            if (!filterName) {
                alert('Filtro não selecionado!');
                return;
            }

            if (!avaliableFilters.includes(filterName)) {
                alert('Filtro não existe! Por favor, escolha outro.');
                return;
            }

            if (currentFilters.includes(filterName)) {
                alert('Filtro já aplicado!');
                return;
            }

            addFilter(filterName);
        });

        items.forEach(item => { dragAndDropHandlers(item) });
    }

    const filterMap = {
        'Shape Index': 'shapeIndex',
        'Curvatura Gaussiana': 'gaussianCurvature',
        'Soma': 'gfSum',
        'Omnivariância': 'gfOmnivariance',
        'Autoentropia': 'gfEigenentropy',
        'Anisotropia': 'gfAnisotropy',
        'Planaridade': 'gfPlanarity',
        'Linearidade': 'gfLinearity',
        'Esfericidade': 'gfSphericity',
        'Variação de superfície': 'gfSurfaceVariation',
        'Verticalidade': 'gfVerticality'
    };

    function addFilter(filter) {
        currentFilters.push(filter);

        const pipelineFilterChild = document.createElement('div');
        pipelineFilterChild.classList.add('pipeline-filter');
        pipelineFilterChild.setAttribute('draggable', true);

        pipelineFilterChild.innerHTML = `
            <div class="collapsible" data-feature="${filter}">
                <span>${filter}</span>
                <button class="remove-filter">X</button>
            </div>
            <div class="content">
                <label for="${filterMap[filter]}KDTreeMethodRadius">Método de computação:</label>
                <input type="radio" id="${filterMap[filter]}KDTreeMethodRadius" name="${filterMap[filter]}KDTreeMethod" value="radius" checked>
                <label for="${filterMap[filter]}KDTreeMethodRadius">Raio</label>
                <input type="radio" id="${filterMap[filter]}KDTreeMethodK" name="${filterMap[filter]}KDTreeMethod" value="k">
                <label for="${filterMap[filter]}KDTreeMethodK">K Vizinhos</label>
                <br/>
                <label for="${filterMap[filter]}KDTreeValue">Valor usado para calcular a vizinhança:</label>
                <input type="number" id="${filterMap[filter]}KDTreeValue" name="${filterMap[filter]}KDTreeValue" value="13" style="width: 40px">
                <br/>
                <label for="${filterMap[filter]}MinThreshold">Threshold mínimo:</label>
                <input type="number" id="${filterMap[filter]}MinThreshold" name="${filterMap[filter]}MinThreshold" value="13" style="width: 80px">
                <br/>
                <label for="${filterMap[filter]}MaxThreshold">Threshold máximo:</label>
                <input type="number" id="${filterMap[filter]}MaxThreshold" name="${filterMap[filter]}MaxThreshold" value="13" style="width: 80px">
                <br/>
            </div>
        `;

        dragAndDropHandlers(pipelineFilterChild);
        pipelineFilterChild.firstElementChild.addEventListener('click', collapse);
        pipelineFilterChild.firstElementChild.lastElementChild.addEventListener('click', removeFilter);
        pipelineContainer.appendChild(pipelineFilterChild);
    }

    function collapse() {
        this.classList.toggle('active');

        const content = this.nextElementSibling;

        if (content.style.display === 'block') {
            content.style.display = 'none';
        } else {
            content.style.display = 'block';
        }
    }

    function removeFilter(e) {
        e.stopPropagation();
        currentFilters.splice(currentFilters.indexOf(this.previousElementSibling.innerHTML), 1);
        document.querySelector(`div[data-feature="${this.parentNode.dataset.feature}"]`).parentNode.remove();
    }

    function handleDragStart(e) {
        this.style.opacity = '0.4';

        dragSrcEl = this;

        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', this.innerHTML);
    }

    function handleDragEnd(e) {
        this.style.opacity = '1';

        items.forEach(function (item) {
            item.classList.remove('over');
        });
    }

    function handleDragOver(e) {
        if (e.preventDefault) {
            e.preventDefault();
        }

        e.dataTransfer.dropEffect = 'move';

        return false;
    }

    function handleDragEnter(e) {
        this.classList.add('over');
    }

    function handleDragLeave(e) {
        this.classList.remove('over');
    }

    function handleDrop(e) {
        e.stopPropagation();

        if (dragSrcEl !== this) {
            dragSrcEl.innerHTML = this.innerHTML;
            this.innerHTML = e.dataTransfer.getData('text/html');

            this.firstElementChild.lastElementChild.addEventListener('click', removeFilter);
            dragSrcEl.firstElementChild.lastElementChild.addEventListener('click', removeFilter);

            this.firstElementChild.addEventListener('click', collapse);
            dragSrcEl.firstElementChild.addEventListener('click', collapse);
        }

        return false;
    }

    function dragAndDropHandlers(item) {
        item.addEventListener('dragstart', handleDragStart, false);
        item.addEventListener('dragenter', handleDragEnter, false);
        item.addEventListener('dragover', handleDragOver, false);
        item.addEventListener('dragleave', handleDragLeave, false);
        item.addEventListener('drop', handleDrop, false);
        item.addEventListener('dragend', handleDragEnd, false);
    }

    // Event Lisntener Functions

    function addPCDFile(blobURL = undefined, cloudName = undefined) {
        let inputUrl = '';
        let filename = '';

        if (blobURL) {
            inputUrl = blobURL;
            filename = cloudName;
        } else {
            inputUrl = URL.createObjectURL(inputFile.files[0]);
            filename = inputFile.files[0].name;
        }

        if (inputUrl) {
            loader.load(inputUrl, pointCloud => {
                if (clearSceneCheckbox.checked) {
                    cleanScene();
                }

                pointCloud.material.size = 0.8;
                scene.add(pointCloud);

                const inputCenter = pointCloud.geometry.boundingSphere.center;
                center.x = inputCenter.x;
                center.y = inputCenter.y;
                center.z = inputCenter.z;

                controls.target.set(center.x, center.y, center.z);
                camera.position.set(center.x, center.y, center.z + 200);
                controls.update();

                const guiColor = gui.addColor(new ColorGUIHelper(pointCloud.material, 'color'), 'value').name(`Color ${fileCounter}`);
                const guiSize = gui.add(new SizeGUIHelper(pointCloud.material, 'size'), 'value', 0, 150, 1).name(`Size ${fileCounter}`);

                fileCounter += 1;
                pcdFile = {
                    cloud: pointCloud,
                    blobURL: inputUrl,
                    filename,
                    guiColor,
                    guiSize,
                };
            });
        }
    }

    async function findFiducialPoint() {
        if (!pcdFile.cloud) {
            alert('Selecione uma nuvem primeiro!!');
            return;
        }

        const fiducialPoint = document.getElementById('nosetip-point').checked ? 'nosetip' : 'eye';

        const features = [...featuresCheckboxes]
            .filter(c => c.checked)
            .sort((a, b) => a.timeval - b.timeval)
            .map(f => f.value).join(',');

        if (fiducialPoint === 'eye' && !features) {
            alert('Selecione alguma feature!');
            return;
        }

        const featuresThreshold = featuresThresholdInput.value.replace(/(^,)|(,$)/g, '');

        if (features.split(',').filter(Boolean).length !== featuresThreshold.split(',').filter(Boolean).length) {
            alert('Número de features e thresholds devem ser iguais.');
            return;
        }

        cleanCloudLogEntries();
        cleanPointAnalysis();

        const inputUrl = pcdFile.blobURL;
        const sendBlob = await fetch(inputUrl).then(blob => blob.blob());
        const randomFilename = Math.random().toString(36).substring(7) + '.pcd'
        const sendFile = new File([sendBlob], randomFilename);

        const flexibilizeThresholds = document.getElementById('flexibilizeThresholds');
        const flexibilizeCrop = document.getElementById('flexibilizeCrop');
        const computationRadiusOrKSize = document.getElementById('computationRadiusOrKSize');
        const computationMethod = document.getElementById('radiusMethod').checked ? 'radius' : 'k';
        const minGaussianCurvature = document.getElementById('minGaussianCurvature');
        const shapeIndexLimit = document.getElementById('shapeIndexLimit');
        const minCropSize = document.getElementById('minCropSize');
        const maxCropSize = document.getElementById('maxCropSize');
        const minPointsToContinue = document.getElementById('minPointsToContinue');
        const removeIsolatedPointsRadius = document.getElementById('removeIsolatedPointsRadius');
        const removeIsolatedPointsThreshold = document.getElementById('removeIsolatedPointsThreshold');
        const nosetipSearchRadius = document.getElementById('nosetipSearchRadius');
        const gfSearchRadius = document.getElementById('gfSearchRadius');

        const formData = new FormData();

        formData.append('flexibilizeThresholds', flexibilizeThresholds.checked);
        formData.append('flexibilizeCrop', flexibilizeCrop.checked);
        formData.append('computationRadiusOrKSize', computationRadiusOrKSize.value);
        formData.append('computationMethod', computationMethod);
        formData.append('minGaussianCurvature', minGaussianCurvature.value);
        formData.append('shapeIndexLimit', shapeIndexLimit.value);
        formData.append('minCropSize', minCropSize.value);
        formData.append('maxCropSize', maxCropSize.value);
        formData.append('minPointsToContinue', minPointsToContinue.value);
        formData.append('removeIsolatedPointsRadius', removeIsolatedPointsRadius.value);
        formData.append('removeIsolatedPointsThreshold', removeIsolatedPointsThreshold.value);
        formData.append('nosetipSearchRadius', nosetipSearchRadius.value);
        formData.append('gfSearchRadius', gfSearchRadius.value);
        formData.append('features', features);
        formData.append('featuresThreshold', featuresThreshold);
        formData.append('fiducialPoint', fiducialPoint);
        formData.append('file', sendFile);

        const response = await fetch('http://localhost:3000/find-fiducial-point', {
            method: 'POST',
            body: formData
        });
        const data = await response.json();

        if (!response.ok) {
            alert('Algum erro ocorreu: ' + data.msg);

            return;
        }

        data.intermediary_clouds.forEach(cloudLog => addPointCloudFromCloudLog(cloudLog));

        const fiducialPointCloudLog = {
            cloud_label: 'Fiducial Point',
            cloud: [{ x: data.point.x, y: data.point.y, z: data.point.z }]
        };

        addPointCloudFromCloudLog(fiducialPointCloudLog, 150, 400, 1, 4, '#FFFFFF');
    }

    async function getPointAnalysis() {
        if (!selectedNosetipCloud || (Object.keys(selectedNosetipCloud).length === 0 && selectedNosetipCloud.constructor === Object)) {
            alert('Selecione um ponto antes de realizar sua análise');
            return;
        }

        const inputUrl = pcdFile.blobURL;
        const sendBlob = await fetch(inputUrl).then(blob => blob.blob());
        const randomFilename = Math.random().toString(36).substring(7) + '.pcd'
        const sendFile = new File([sendBlob], randomFilename);

        const method = document.getElementById('pointAnalysisRadiusMethod').checked ? 'radius' : 'k';
        const pointAnalysisComputationRadiusOrKSize = document.getElementById('pointAnalysisComputationRadiusOrKSize');

        const formData = new FormData();

        formData.append('file', sendFile);
        formData.append('computationMethod', method);
        formData.append('computationSize', pointAnalysisComputationRadiusOrKSize.value);
        formData.append('pointIndexToAnalyze', selectedNosetipCloud.index);

        const response = await fetch('http://localhost:3000/point-analysis', {
            method: 'POST',
            body: formData
        });
        const data = await response.json();

        if (!response.ok) {
            alert('Algum erro ocorreu: ' + data.msg);

            return;
        }

        insertPointAnalysisOnHTML(data.point_analysis);

        const cloudLog = {
            cloud_label: 'Neighborhood',
            cloud: data.point_analysis.neighborhood
        };

        addPointCloudFromCloudLog(cloudLog);
    }

    function onPointerMove(event) {
        pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
    }

    function toggleRaycaster() {
        if (runningRaycaster) {
            scene.remove(sphere);
            canvas.removeEventListener('click', runRaycast);
        } else {
            scene.add(sphere);
            canvas.addEventListener('click', runRaycast);
        }

        runningRaycaster = !runningRaycaster;
    }

    function runRaycast(e) {
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObject(pcdFile.cloud);

        if (intersects.length) {
            cleanSelectedNosetipCloud();
            cleanPointAnalysis();

            const newColor = new THREE.Color();
            newColor.setRGB(1, 1, 1);

            const index = intersects[0].index;

            toggleRaycaster();

            const material = new THREE.PointsMaterial({ size: 1.5, color: '#FFFFFF' });

            const point = {
                x: pcdFile.cloud.geometry.getAttribute('position').getX(index),
                y: pcdFile.cloud.geometry.getAttribute('position').getY(index),
                z: pcdFile.cloud.geometry.getAttribute('position').getZ(index)
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(
                [new THREE.Vector3(point.x, point.y, point.z)]
            );

            const newCloud = new THREE.Points(geometry, material);
            scene.add(newCloud);

            const guiColor = gui.addColor(new ColorGUIHelper(newCloud.material, 'color'), 'value').name(`Selected point ${fileCounter}`);
            const guiSize = gui.add(new SizeGUIHelper(newCloud.material, 'size'), 'value', 150, 400, 1).name(`Selected point ${fileCounter}`);

            selectedNosetipCloud = {
                cloud: newCloud,
                point,
                index,
                guiColor,
                guiSize
            }

            fileCounter += 1;
        }
    }

    function toggleFocusRaycaster(e) {
        if (runningFocusRaycaster) {
            canvas.removeEventListener('click', focusOnNewPoint);
        } else {
            canvas.addEventListener('click', focusOnNewPoint);
        }

        runningFocusRaycaster = !runningFocusRaycaster;
    }

    function insertPointAnalysisOnHTML(pointAnalysis) {
        document.getElementById('pointAnalysisResult').innerHTML = `
        <span><b>Point (x,y,z): </b>(${selectedNosetipCloud.point.x.toFixed(5)}, ${selectedNosetipCloud.point.y.toFixed(5)}, ${selectedNosetipCloud.point.z.toFixed(5)})</span><br/>
        <span><b>Número de pontos: </b>${pointAnalysis.neighborhood.length}</span><br/>
        <span><b>Gaussian Curvature: </b>${pointAnalysis.gaussian_curvature.toFixed(5)}</span><br/>
        <span><b>Shape Index: </b>${pointAnalysis.shape_index.toFixed(5)}</span><br/>
        <span><b>Normal (x,y,z): </b>(${pointAnalysis.normal.x.toFixed(5)}, ${pointAnalysis.normal.y.toFixed(5)}, ${pointAnalysis.normal.z.toFixed(5)})</span><br/>
        <span><b>PCs (k1,k2): </b>(${pointAnalysis.principal_curvatures.k1.toFixed(5)}, ${pointAnalysis.principal_curvatures.k2.toFixed(5)})</span><br/>
        <span><b>Soma: </b>${pointAnalysis.geometric_features.sum.toFixed(5)}</span><br/>
        <span><b>Omnivariância: </b>${pointAnalysis.geometric_features.omnivariance.toFixed(5)}</span><br/>
        <span><b>Autoentropia: </b>${pointAnalysis.geometric_features.eigenentropy.toFixed(5)}</span><br/>
        <span><b>Anisotropia: </b>${pointAnalysis.geometric_features.anisotropy.toFixed(5)}</span><br/>
        <span><b>Planaridade: </b>${pointAnalysis.geometric_features.planarity.toFixed(5)}</span><br/>
        <span><b>Linearidade: </b>${pointAnalysis.geometric_features.linearity.toFixed(5)}</span><br/>
        <span><b>Variação de superfície: </b>${pointAnalysis.geometric_features.surfaceVariation.toFixed(5)}</span><br/>
        <span><b>Esfericidade: </b>${pointAnalysis.geometric_features.sphericity.toFixed(5)}</span><br/>
        <span><b>Verticalidade: </b>${pointAnalysis.geometric_features.verticality.toFixed(5)}</span><br/>
        `;
    }

    function addPointCloudFromCloudLog(cloudLog, minSize = 0, maxSize = 150, step = 1, initialPointSize = 2, color = undefined) {
        let materialColor = color;

        if (!color) {
            materialColor = `#${Math.floor(Math.random()*16777215).toString(16)}`;
        }

        const material = new THREE.PointsMaterial({ size: initialPointSize, color: materialColor });
        const points = [];

        cloudLog.cloud.forEach(point => {
            points.push(new THREE.Vector3(point.x, point.y, point.z));
        });

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const newCloud = new THREE.Points(geometry, material);
        newCloud.userData.points = points;
        newCloud.name = 'neighborhood';
        scene.add(newCloud);

        if (!pcdFile || (Object.keys(pcdFile).length === 0 && pcdFile.constructor === Object)) {
            newCloud.geometry.computeBoundingSphere();
            const inputCenter = newCloud.geometry.boundingSphere.center;
            center.x = inputCenter.x;
            center.y = inputCenter.y;
            center.z = inputCenter.z;

            controls.target.set( center.x, center.y, center.z );
            controls.update();
        }

        const guiColor = gui.addColor(new ColorGUIHelper(newCloud.material, 'color'), 'value').name(cloudLog.cloud_label);
        const guiSize = gui.add(new SizeGUIHelper(newCloud.material, 'size'), 'value', minSize, maxSize, step).name(cloudLog.cloud_label);

        cloudLogFiles.push({
            cloud: newCloud,
            guiColor,
            guiSize,
        })

        fileCounter += 1;
    }

    function download() {
        if (!selectedNosetipCloud.point) {
            return;
        }

        const saveData = (function () {
            const a = document.createElement('a');
            document.body.appendChild(a);
            a.style = 'display: none';
            return (data, fileName) => {
                const blob = new Blob([data], { type: 'octet/stream' });
                const url = window.URL.createObjectURL(blob);
                a.href = url;
                a.download = fileName;
                a.click();
                window.URL.revokeObjectURL(url);
            };
        }());

        const cloud = scene.getObjectByName('neighborhood', true);

        let baseFile = '# .PCD v0.7 - Point Cloud Data file format\nVERSION 0.7\nFIELDS x y z\nSIZE 4 4 4\nTYPE F F F\nCOUNT 1 1 1\nWIDTH 1\nHEIGHT 1\nVIEWPOINT 0 0 0 1 0 0 0\nPOINTS 1\nDATA ascii\n';
        baseFile = baseFile + `${selectedNosetipCloud.point.x} ${selectedNosetipCloud.point.y} ${selectedNosetipCloud.point.z}\n`;

        const points = cloud.userData.points;
        for (let i = 0; i < points.length; i++) {
            baseFile += `${points[i].x} ${points[i].y} ${points[i].z}\n`
        }

        saveData(baseFile, `point_selected_${pcdFile.filename}`);
    }

    function cleanPointAnalysis() {
        document.getElementById('pointAnalysisResult').innerHTML = '';
    }

    function cleanSelectedNosetipCloud() {
        if ('cloud' in selectedNosetipCloud && selectedNosetipCloud.cloud) {
            scene.remove(selectedNosetipCloud.cloud);
            delete selectedNosetipCloud.cloud;
        }

        if ('guiColor' in selectedNosetipCloud && selectedNosetipCloud.guiColor) {
            gui.remove(selectedNosetipCloud.guiColor);
            delete selectedNosetipCloud.guiColor;
        }

        if ('guiSize' in selectedNosetipCloud && selectedNosetipCloud.guiSize) {
            gui.remove(selectedNosetipCloud.guiSize);
            delete selectedNosetipCloud.guiSize;
        }

        selectedNosetipCloud = {};
        cleanPointAnalysis();
    }

    function cleanCloudLogEntries() {
        for (let i = 0; i < cloudLogFiles.length; i++) {
            const c = cloudLogFiles[i];

            scene.remove(c.cloud);
            gui.remove(c.guiColor);
            gui.remove(c.guiSize);
        }

        cloudLogFiles = [];
    }

    function cleanPCDFile() {
        if ('cloud' in pcdFile && pcdFile.cloud) {
            scene.remove(pcdFile.cloud);
        }

        if ('guiColor' in pcdFile && pcdFile.guiColor) {
            gui.remove(pcdFile.guiColor);
        }

        if ('guiSize' in pcdFile && pcdFile.guiSize) {
            gui.remove(pcdFile.guiSize);
        }

        pcdFile = {};
    }

    function cleanScene() {
        cleanPCDFile();
        cleanSelectedNosetipCloud();
        cleanCloudLogEntries();
    }

    function focusOnNewPoint(e) {
        mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;

        focusRaycaster.setFromCamera(mouse, camera);

        const intersects = focusRaycaster.intersectObject(pcdFile.cloud);

        if (intersects.length) {
            const index = intersects[0].index;

            const point = {
                x: pcdFile.cloud.geometry.getAttribute('position').getX(index),
                y: pcdFile.cloud.geometry.getAttribute('position').getY(index),
                z: pcdFile.cloud.geometry.getAttribute('position').getZ(index)
            }

            controls.target.set( point.x, point.y, point.z );
            camera.position.set( point.x, point.y, point.z + 50 );
            controls.update();

            toggleFocusRaycaster();
        }
    }

    init();
    animate();
</script>
</html>
